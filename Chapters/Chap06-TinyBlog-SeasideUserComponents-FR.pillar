!! Des composants web pour TinyBlog

Dans ce chapitre, commençons par définir une interface publique permettant d'afficher les posts du blog. Dans un prochain chapitre, nous développerons une interface d'administration pour le ou les auteurs du blog.

Si vous avez le sentiment d'être un peu perdu la figure *@AssociationArchitectureUser* vous montre les composants sur lesquels nous allons travailler dans ce chapitre. 

+L'architecture des composants Users.>file://figures/ApplicationArchitectureUser.pdf|width=75|label=AssociationArchitectureUser+

Le travail présenté dans la suite est indépendant de celui sur Voyage et sur la base de données MongoDB.
Les instructions pour charger le code des chapitres précédents sont disponibles dans le dernier chapitre.

!!! Composants visuels 

Nous sommes maintenant prêts à définir les composants visuels de notre application Web.

La figure *@ComponentOverview* montre les différents composants que nous allons développer et où ils se situent.

+Les composants composant l'application TinyBlog.>file://figures/ComponentOverview.pdf|width=75|label=ComponentOverview+

!!!!Le composant TBScreenComponent

Le composant ==TBApplicationRootComponent== contiendra des composants sous-classes de la classe abstraite ==TBScreenComponent==. Cette classe nous permet de factoriser les comportements que nous souhaitons partager entre tous nos composants.

[[[
WAComponent subclass: #TBScreenComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Les différents composants d'interface de TinyBlog ont besoin d'accéder aux règles métier de l'application. Dans le protocole 'accessing', créons une méthode ==blog== qui retourne une instance de ==TBBlog== (ici notre singleton). Notez que cette méthode pourrait renvoyer l'instance de blog avec laquelle elle a été configurée au préalable.

[[[
TBScreenComponent >> blog
   "Return the current blog. In the future we will ask the
   session to return the blog of the currently logged in user."
   ^ TBBlog current
]]]

En inspectant l'objet blog retourné par ==TBBlog current==, vérifier qu'il contient bien des posts. Si ce n'est pas le cas, exécuter ==TBBlog createDemoPosts==.

Par la suite, si l'on souhaite étendre TinyBlog pour qu'un utilisateur puisse avoir plusieurs blogs, il suffira de modifier cette méthode pour utiliser des informations stockées dans la session active (Voir ==TBSession== dans le chapitre suivant).

Définissez la méthode ==renderContentOn:== de ce composant comme suit temporairement. Notez que pour l'instant, nous n'affichons pas ce composant. 

[[[
TBScreenComponent >> renderContentOn: html
   html text: 'Hello from TBScreenComponent'
]]]

!!!Utilisation du composant Screen

Bien que le composant ==TBScreenComponent== n'ait pas vocation à être utilisé directement, nous allons l'utiliser de manière temporaire pendant que nous développons les autres composants. 
Nous ajoutons la variable d'instance ==main== dans la classe ==TBApplicationRootComponent==. Nous l'initialisons dans la méthode ==initialize== suivante et redéfinissons la méthode ==children==. Nous obtenons la situation décrite par la figure *@compt1*.

[[[
WAComponent subclass: #TBApplicationRootComponent
	instanceVariableNames: 'main'
	classVariableNames: ''
	package: 'TinyBlog-Components'
]]]

+Le composant ==ApplicationRootComponent== utilise de manière temporaire le composant ==ScreenComponent== qui a un ==HeaderComponent==.>file://figures/ComponentRelationship1.pdf|width=75|label=compt1+

[[[
TBApplicationRootComponent >> initialize
   super initialize.
   main := TBScreenComponent new
]]]


[[[
TBApplicationRootComponent >> renderContentOn: html
   html render: main
]]]

Nous déclarons aussi la relation de contenu en retournant main parmi les enfants de ==TBApplicationRootComponent==.
[[[
TBApplicationRootComponent >> children
   ^ { main }
]]]

Si vous rafraichissez votre browser, vous allez voir l'affichage produit par le sous-composant ==TBScreenComponent==. 

!!!Pattern de définition  de composants

Nous allons souvent utiliser la même façon de procéder:
- nous définissons d'abord la classe et le comportement d'un nouveau composant;
- puis, nous allons y faire référence depuis la classe qui utilisera ce composant pour satisfaire les contraintes de Seaside;
- en particulier, nous exprimons la relation entre un composant et un sous-composant en redéfinissant la méthode ==children==.


!!!Définition du composant TBHeaderComponent

Définissons une en-tête commune à toutes les pages Web de TinyBlog dans un composant nommé ==TBHeaderComponent==.
Ce composant sera inséré dans la partie supérieure de chaque composant (==TBPostsListComponent== par exemple). Nous appliquons le schéma présenté avant: définition d'une classe, référence depuis la classe utilisatrice, redéfinition de la méthode ==children==.

Nous définissons d'abord sa classe, puis nous allons y faire référence depuis la classe qui l'utilise. Ce faisant nous allons montrer comment un composant exprime sa relation à un sous-composant. 

[[[
WAComponent subclass: #TBHeaderComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Le protocole 'rendering' contient la méthode ==renderContentOn:== chargée d'afficher l'entête.

[[[
TBHeaderComponent >> renderContentOn: html
   html tbsNavbar beDefault with: [
      html tbsNavbarBrand
         url: '#';
         with: 'TinyBlog' ]
]]]

L'entête (header) est affichée à l'aide d'une barre de navigation Bootstrap (voir la figure *@navBlog*)

Par défaut dans une barre de navigation Bootstrap, il y a un lien sur ==tbsNavbarBrand== qui est ici inutile (sur le titre de l'application). Ici nous l'initialisons avec une ancre =='#'== de façon à ce que si l'utilisateur clique sur le titre, il ne se passe rien. En général, cliquer sur le titre de l'application permet de revenir à la page de départ du site. 

!!!!Améliorations possibles
Le nom du blog devrait être paramétrable à l'aide d'une variable d'instance dans la classe ==TBBlog==
et le l'en-tête pourrait afficher ce titre.

+TinyBlog avec une barre de navigation.>file://figures/navBlog.png|width=75|label=navBlog+

!!!Utilisation du composant header

Complétons maintenant la classe ==TBScreenComponent== qui est la super-classe abstraite (nous l'utilisons directement pour l'instant) dans l'architecture finale de tous nos composants afin qu'elle affiche une instance de ==TBHeaderComponent==.
Pour éviter d'instancier systématiquement le composant ==TBHeaderComponent== à chaque fois qu'un composant est appelé, créons et initialisons une variable d'instance ==header== dans ==TBScreenComponent==.

[[[
WAComponent subclass: #TBScreenComponent
   instanceVariableNames: 'header'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Créons une méthode ==initialize== dans le protocole 'initialize-release':

[[[
TBScreenComponent >> initialize
   super initialize.
   header := TBHeaderComponent new
]]]


!!!Relation composite-composant

En Seaside, les sous-composants d'un composant doivent être retournés par le composite en réponse au message ==children==. Définissons que l'instance du composant ==TBHeaderComponent== est un enfant de ==TBScreenComponent== dans la hiérarchie des composants Seaside (et non entre classes Pharo). Nous faisons cela en spécialisant la méthode ==children== pour quelle retourne tous les composants enfants (ici seulement l'instance de ==TBHeaderComponent== référencer depuis la variable ==header==).

[[[
TBScreenComponent >> children
   ^ { header }
]]]

Affichons maintenant le composant dans la méthode ==renderContentOn:== (protocole 'rendering'):

[[[
TBScreenComponent >> renderContentOn: html
   html render: header
]]]

Si vous faites un rafraichissement de l'application dans votre navigateur web vous devez voir apparaitre l'en-tête comme sur le haut de la Figure *@navBlog*.

@todo Luc here

!!!Liste des posts

Nous allons afficher la liste des posts - ce qui reste d'ailleurs le but d'un blog. Ici nous parlons de l'accès public offert aux lecteurs du blog. 

Créons un composant ==TBPostsListComponent== qui hérite de ==TBScreenComponent==:

[[[
TBScreenComponent subclass: #TBPostsListComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Ajoutons une méthode ==renderContentOn:== (protocole rendering) provisoire pour tester l'avancement de notre application (voir Figure *@elementary*).

[[[
TBPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   html text: 'Blog Posts here !!!'
]]]

+Le composant ==ApplicationRootComponent== utilise le composant ==PostsListComponent==.>file://figures/ComponentRelationship2.pdf|width=75|label=compt2+

Nous pouvons maintenant dire au composant de l'application d'utiliser ce composant comme illustré dans la figure *@compt2*. Pour cela nous modifions-la ainsi: 

[[[
TBApplicationRootComponent >> initialize
   super initialize.
   main := TBPostsListComponent new. 
]]]

Editer cette méthode n'est pas une bonne pratique. Nous ajoutons une méthode setter qui nous permettra
de changer dynamiquement de composant dans le futur tout en gardant le composant actuel pour une initialisation par défaut. 

[[[
TBApplicationRootComponent >> main: aComponent
   main := aComponent
]]]

+TinyBlog avec une liste de bulletins plutot élémentaire.>file://figures/ElementaryListPost.png|width=65|label=elementary+


!!!Le composant Post

Nous allons maintenant définir le composant ==TBPostComponent== qui affiche le contenu d'un bulletin (post).

Chaque bulletin du blog sera représenté visuellement par une instance de  ==TBPostComponent== qui affiche le titre, la date et le contenu d'un bulletin. Nous allons obtenir la situation décrite par la figure *@compt3*.

+Ajout du composant Post.>file://figures/ComponentRelationship3.pdf|width=75|label=compt3+

[[[
WAComponent subclass: #TBPostComponent
   instanceVariableNames: 'post'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBPostComponent >> initialize
      super initialize.
      post := TBPost new.
]]]

[[[      
TBPostComponent >> title
   ^ post title
]]]

[[[
TBPostComponent >> text
   ^ post text
]]]

[[[
TBPostComponent >> date
   ^ post date
]]]

Ajoutons la méthode ==renderContentOn:== qui définit l'affichage du post.

[[[
TBPostComponent >> renderContentOn: html
   html heading level: 2; with: self title.
   html heading level: 6; with: self date.
   html text: self text
]]]


!!!!A propos des formulaires

Dans le chapitre sur l'interface d'administration et qui utilise Magritte, nous montrerons qu'il est rare de définir un composant de manière aussi manuelle. En effet, Magritte permet de décrire les données manipulées et offre ensuite la possibilité de générer automatiquement des composants Seaside. Le code équivalent serait comme suit: 

[[[
TBPostComponent >> renderContentOn: html
   "DON'T WRITE THIS YET"
   html render: post asComponent
]]]


!!!Afficher les bulletins (posts)

Maintenant nous pouvons afficher des posts présents dans la base.

Il ne reste plus qu'à modifier la méthode ==renderContentOn:== de la classe ==TBPostsListComponent== pour afficher l'ensemble des bulletin visibles présents dans la base.

[[[
TBPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   self blog allVisibleBlogPosts do: [ :p |
      html render: (TBPostComponent new post: p) ]
]]]

Rafraichissez la page de votre navigateur et vous devez obtenir un message d'erreur.

!!!Débugger les erreurs

Par défaut, lorsqu'une erreur se produit dans une application, Seaside retourne une page HTML contenant un message. Vous pouvez changer ce message mais le plus pratique pendant le développement de l'application est de configurer Seaside pour qu'il ouvre un debugger dans Pharo. Pour cela, exécuter le code suivant :

[[[
(WAAdmin defaultDispatcher handlerAt: 'TinyBlog') 
    exceptionHandler: WADebugErrorHandler
]]] 

Rafraîchissez la page de votre navigateur et vous devez obtenir un debugger côté Pharo.
L'analyse de la pile d'appels montre qu'il manque la méthode suivante :

[[[
TBPostComponent >> post: aPost
   post := aPost
]]]


Vous pouvez ajouter cette méthode dans le debugger avec le bouton ==Create==. Quand c'est fait, appuyez sur le bouton ==Proceed==. La page de votre navigateur doit maintenant montrer la même chose que la Figure *@better*.

+TinyBlog avec une liste de posts.>file://figures/betterListPosts.png|width=75|label=better+


!!!Affichage de la liste des posts avec Bootstrap

Nous allons utiliser Bootstrap pour rendre la liste un peu plus jolie à l'aide d'un container en utilisant le message ==tbsContainer: == comme suit :

[[[
TBPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   html tbsContainer: [ 
      self blog allVisibleBlogPosts do: [ :p |
          html render: (TBPostComponent new post: p) ] ]
]]]

Rafraichissez la page et vous devez obtenir la Figure *@container*.
+TinyBlog avec une liste de posts élémentaire.>file://figures/ContainerList.png|width=75|label=container+


!!! Relation composite composants

Alors que la solution fonctionne, Seaside nécessite que les enfants (ici ==TBPostComponent==) d'un composite (ici ==TBPostsListComponent==) soient accessibles via la méthode ==super children , ==. Nous allons donc transformer la solution précédente pour suivre le framework.

Nous ajoutons une variable d'instance ==postComponents==.

[[[
TBScreenComponent subclass: #TBPostsListComponent
	instanceVariableNames: 'postComponents'
	classVariableNames: ''
	package: 'TinyBlog-Components'
]]]

[[[
TBPostsListComponent >> initialize
	super initialize.
	postComponents := OrderedCollection new.
]]]

La méthode ==postComponents== calcule et rend les composants pour les bulletins. 

[[[
TBPostsListComponent >> postComponents 
	postComponents := self readSelectedPosts
			collect: [ :each | TBPostComponent new post: each ].
	^ postComponents 
]]]

[[[
TBPostsListComponent >> children 
	^ self postComponents, super children
]]]

Et nous redéfinissons la méthode ==renderContentOn:== pour utiliser les méthodes définies avant.
[[[
TBPostsListComponent >> renderContentOn: html
	super renderContentOn: html.
	html tbsContainer: [ 
		self postComponents do: [ :p |
				html render: p ] ]
]]]



!!!Affichage des posts par catégorie

Les posts sont classés par catégorie. Par défaut, si aucune catégorie n'a été précisée, ils sont rangés dans une catégorie spéciale dénommée "Unclassified".

Nous allons créer un composant pour gérer une liste de catégories nommée: ==TBCategoriesComponent==.

!!!!Definition d'un composant pour les catégories

Nous avons besoin d'un composant qui affiche la liste des catégories présentes dans la base et permet d'en sélectionner une. Ce composant devra donc avoir la possibilité de communiquer avec le composant ==TBPostsListComponent== afin de lui communiquer la catégorie courante. La situation est décrite par la figure *@compt4*.

Rappellez-vous qu'une categorie est simplement exprimée comme une chaine dans le modèle défini dans le Chapitre *@cha:model* et comme l'illustre le test suivant.

[[[
testAllBlogPostsFromCategory
	self assert: (blog allBlogPostsFromCategory: 'First Category') size equals: 1
]]]


+Ajout du composant Categories.>file://figures/ComponentRelationship4.pdf|width=75|label=compt4+


Nous définissons un nouveau composant nommé ==TBCategoriesComponent==. Ce composant va garder une liste
de chaines pour chacune des catégories ainsi qu'un pointeur sur le composant postsList associé.

[[[
WAComponent subclass: #TBCategoriesComponent
   instanceVariableNames: 'categories postsList'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Nous définissons les accesseurs associés.

[[[
TBCategoriesComponent >> categories
   ^ categories
]]]

[[[
TBCategoriesComponent >> categories: aCollection
   categories := aCollection
]]]

[[[
TBCategoriesComponent >> postsList: aComponent
      postsList := aComponent
]]]

[[[
TBCategoriesComponent >> postsList
   ^ postsList
]]]

Nous définissons aussi une méthode de création au niveau classe.

[[[
TBCategoriesComponent class >> categories: categories postsList: aTBScreen
   ^ self new categories: categories; postsList: aTBScreen 
]]]


Nous avons donc besoin d'ajouter une variable d'instance pour stocker la catégorie courante dans la classe ==TBPostsListComponent==.

[[[
TBScreenComponent subclass: #TBPostsListComponent
   instanceVariableNames: 'currentCategory postComponents'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Nous définissons les accesseurs associés.
[[[
TBPostsListComponent >> currentCategory
   ^ currentCategory
]]]

[[[
TBPostsListComponent >> currentCategory: anObject
   currentCategory := anObject
]]]


!!!! La méthode selectCategory:
La méthode ==selectCategory:== (protocole 'action') communique au composant ==TBPostsListComponent== la nouvelle catégorie courante.

[[[
TBCategoriesComponent >> selectCategory: aCategory
   postsList currentCategory: aCategory
]]]

Notez que si nous voulions avoir un effet visuel plus avancé le composant catégories devrait peut être lui aussi garder trace de la 
catégorie couramment sélectionnée. 



!!! Rendu des catégories
Nous pouvons maintenant ajouter une méthode (protocole 'rendering') pour afficher les catégories sur la page. En particulier pour chaque catégorie nous définissons le fait que cliquer sur la catégorie la sélectionne comme la catégorie courante.
Nous utilisons un callback (message ==callback:==): l'argument d'un callback est un block Pharo et peut contenir n'importe quelle expression. Cela illustre la puissance de Seaside.

[[[
TBCategoriesComponent >> renderCategoryLinkOn: html with: aCategory
   html tbsLinkifyListGroupItem
      callback: [ self selectCategory: aCategory ];
      with: aCategory
]]]

Reste maintenant à écrire la méthode de rendu du composant: on itère sur toutes les catégories et on les affiche

[[[
TBCategoriesComponent >> renderContentOn: html
   html tbsListGroup: [
      html tbsListGroupItem
         with: [  html strong: 'Categories' ].
      categories do: [ :cat | 
         self renderCategoryLinkOn: html with: cat ] ]
]]]

Nous avons presque fini mais il faut encore afficher la liste des catégories et mettre à jour la liste des posts en fonction de la catégorie courante. 

!!!Mise à jour des Posts

Nous devons mettre à jours les bulletins, pour cela, modifions la méthode de rendu du composant ==TBPostsListComponent==.

La méthode ==readSelectedPosts== récupère dans la base les bulletins à afficher. Si elle vaut ==nil==, l'utilisateur n'a pas encore sélectionné une catégorie et l'ensemble des bulletins visibles de la base est affiché. Si elle contient une valeur autre que ==nil==, l'utilisateur a sélectionné une catégorie et l'application affiche alors la liste des bulletins attachés à la catégorie.

[[[
TBPostsListComponent >> readSelectedPosts
   ^ self currentCategory
      ifNil: [ self blog allVisibleBlogPosts ]
      ifNotNil: [ self blog allVisibleBlogPostsFromCategory: self currentCategory ]
]]]

Nous redéfinissons la méthode ==postComponents== pour utiliser la méthode ==readSelectedPosts==.

[[[
TBPostsListComponent >> postComponents
	postComponents := self readSelectedPosts
			collect: [ :each | TBPostComponent new post: each ].
	^ postComponents 
]]]


Nous définissons une méthode créant le composant catégorie

[[[
TBPostsListComponent >> categoriesComponent
	^ TBCategoriesComponent
           categories: self blog allCategories
            postsList: self
]]]

LUC: mais ici on cree plein de composant pour rien?
cela serait mieux de mettre cela dans une variable d'instance. 

Nous devons redéfinir la method ==children== pour que le composant des catégories soit au rendu par la méthode ==children==.

[[[
TBPostsListComponent >> children 
	^ (self postComponents, super children) add: self categoriesComponent
]]]


Nous pouvons maintenant modifier la méthode chargée du rendu de la liste des bulletins :

[[[
TBPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   html render: self categoriesComponent
   html tbsContainer: [ 
		self postComponents do: [ :p |
				html render: p ] ]
]]]

Une instance du composant ==TBCategoriesComponent== est ajoutée sur la page et permet de sélectionner la catégorie courante (voir la figure *@ugly*).

+Catégories afin de sélectionner les posts.>file://figures/categoriesUgly.png|width=75|label=ugly+


!!!Look et agencement

Nous allons maintenant agencer le composant ==TBPostsListComponent== en utilisant une mise en place d'un 'responsive design' pour la liste des bulletins. Cela veut dire que le style CSS va adapter les composants à l'espace disponible.

Les composants sont placés dans un container Bootstrap puis agencés sur une ligne avec deux colonnes. La dimension des colonnes est déterminée en fonction de la résolution (viewport) du terminal utilisé. Les 12 colonnes de Bootstrap sont réparties entre la liste des catégories et la liste des posts. Dans le cas d'une résolution faible, la liste des catégories est placée au dessus de la liste des posts (chaque élément occupant 100\% de la largeur du container).

[[[
TBPostsListComponent >> renderContentOn: html

	super renderContentOn: html.
	html
		tbsContainer: [ html tbsRow
				showGrid;
				with: [ html tbsColumn
						extraSmallSize: 12;
						smallSize: 2;
						mediumSize: 4;
						with: [ html render: self categoriesComponent ].
					html tbsColumn
						extraSmallSize: 12;
						smallSize: 10;
						mediumSize: 8;
						with: [ self postComponents do: [ :p | html render: p ] ] ] ]
]]]

Vous devez obtenir une application proche de celle représentée figure *@nicer5*.

+Avec un meilleur agencement.>file://figures/NicerCategories.png|width=75|label=nicer5+

Lorsqu'on sélectionne une catégorie, la liste des posts est bien mise à jour.
Toutefois, l'entrée courante dans la liste des catégories n'est pas sélectionnée.
Pour cela, on modifie la méthode suivante :

[[[
TBCategoriesComponent >> renderCategoryLinkOn: html with: aCategory
   html tbsLinkifyListGroupItem
      class: 'active' if: aCategory = self postsList currentCategory ;
      callback: [ self selectCategory: aCategory ]; 
      with: aCategory
]]]

Bien que le code fonctionne, on ne doit pas laisser la méthode ==TBPostsListComponent >> renderContentOn: html== dans un tel état. Elle est bien trop longue et difficilement réutilisable. Proposer une solution. 

!!!Notre solution: Plein de petites méthodes
Nous allons découper la méthode en plusieurs petites méthodes. 

[[[
TBPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   html
      tbsContainer: [ 
         html tbsRow
            showGrid;
            with: [ self renderCategoryColumnOn: html.
                  self renderPostColumnOn: html ] ]
]]]

[[[
TBPostsListComponent >> renderCategoryColumnOn: html
   html tbsColumn
      extraSmallSize: 12;
      smallSize: 2;
      mediumSize: 4;
      with: [ self basicRenderCategoriesOn: html ]
]]]

[[[
TBPostsListComponent >> basicRenderCategoriesOn: html
   html render: self categoriesComponent 
]]]

[[[
TBPostsListComponent >> renderPostColumnOn: html
   html tbsColumn
         extraSmallSize: 12;
         smallSize: 10;
         mediumSize: 8;
         with: [ self basicRenderPostsOn: html ] 
]]]

[[[
TBPostsListComponent >> basicRenderPostsOn: html
   self postComponents do: [ :p | html render: p ]
]]]

Nous voici prêts à définir la partie administrative de l'application.

+Final TinyBlog Public UI.>file://figures/finalPublicWebPage.png|width=85|label=final+

L'application finale devrait ressembler à la figure *@final*.

!!! Conclusion
Avec Seaside, le programmeur n'a pas à se soucier de gérer les requêtes web, ni l'état de l'application. Il définit des composants qui sont créés et sont proches des composants pour applications de bureau.

Un composant Seaside est responsable d'assurer son rendu en spécialisant la méthode ==renderContentOn:==.
De plus un composant doit retourné ses sous-composants en spécialisant la méthode ==children==.

Nous avons défini une interface pour notre blog en utilisant un ensemble de composants définissant chacun
leur propre état et leurs responsabilités. Maintenant il faut remarquer que de très nombreuses applications se construisent de la même manière. Donc vous avez les bases pour définir de nombreuses applications web. Dans le chapitre suivant nous allons vous montrer un aspect avancé qui permet la définition automatique de formulaires ou d'objets ayant de nombreux champs.

!!!! Améliorations possibles

A titre d'exercice, vous pouvez :
- trier les catégories par ordre alphabétique
- ajouter un lien nommé 'All' dans la liste des catégories permettant d'afficher toutes les posts visible quelque soit leur catégorie.






