!! Authentification et Session 

Le scénario assez classique que nous allons développer dans ce chapitre est le suivant : l'utilisateur doit s'authentifier pour accéder à la partie administration de TinyBlog. Il le fait à l'aide d'un compte et d'un mot de passe. 

Dans la suite, nous commencerons donc par définir un composant d'identification.
Cela va nous permettre d'illustrer comment la saisie de champs utilise de manière élégante les variables d'instances d'un composant ainsi que l'invocation de composants. 
Nous intègrerons ce composant d'identification dans la partie publique de TinyBlog rendue par le composant
gérant la liste des bulletins (==TBPostsListComponent==). Enfin, nous montrerons aussi comment stocker l'utilisateur connecté à l'aide d'une session.

+Gérant l'authentification pour accéder à l'administration.>file://figures/ApplicationArchitectureAdminHeader.pdf|width=75|label=ApplicationArchitectureAdminHeader+

!!! Composant d'administration simple (v1)

Définissons un composant d'administration très simple. Ce composant hérite de la classe ==TBScreenComponent== comme mentionné dans un chapitre précédent et illustré dans la figure *@ApplicationArchitectureAdminHeader*.

[[[
TBScreenComponent subclass: #TBAdminComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Nous définissons une première version de la méthode de rendu afin de pourvoir tester.

[[[
TBAdminComponent >> renderContentOn: html
   super renderContentOn: html.
   html tbsContainer: [
      html heading: 'Blog Admin'.
      html horizontalRule ]
]]]

!!! Intégration du composant d'administration simple (v1)


C'est depuis le composant ==TBPostsListComponent== (partie publique de TinyBlog) que nous donnerons accès à la partie administration via un lien placé sous la liste des catégories. Pour cela, modifions la méthode ==renderCategoryColumnOn:== de ce composant ainsi: 

[[[
TBPostsListComponent >> renderCategoryColumnOn: html
   html tbsColumn
      extraSmallSize: 12;
      smallSize: 2;
      mediumSize: 4;
      with: [
         self basicRenderCategoriesOn: html.
         self renderSignInOn: html ]
]]]

On définit également une méthode qui affiche un lien permettant d'accéder à la partie administration du site.
Lorsque l'utilisateur clique sur ce lien, la méthode ==gotoToAdministration== est exécutée. 
La méthode ==call:== de Seaside permet de remplacer le composant courant ==TBPostsListComponent== par une instance du composant ==TBAdminComponent== et ainsi voir la partie administration. Vous remarquerez que cette première solution est très simple et sans authentification.

[[[
TBPostsListComponent >> renderSignInOn: html
   html anchor 
		callback: [ self gotoToAdministration ];
		with: 'admin'
]]]


[[[
TBPostsListComponent >> gotoToAdministration
	self call: TBAdminComponent new
]]]	

+Lien simple vers la partie administration.>file://figures/SimpleAdminLink.png|width=100|label=SimpleAdminLink+

En rechargeant la page de TinyBlog dans votre navigateur, nous voyons maintenant un lien 'admin'et lorsque l'on clique dessus, nous voyons bien la partie administration comme sur la figure *@SimpleAdminLink*.

Modifions maintenant ce premier résultat pour ajouter l'authentification.

@todo answer:


!!! Composant d'identification

Commençons par développer un composant d'identification qui lorsqu'il sera invoqué ouvrira une boite de dialogue pour demander un login et un mot de passe. Le résultat que nous voulons obtenir est montré sur la figure *@authentification*. Une telle fonctionnalité devrait faire partie d'une bibliothèque de composants de base en Seaside. Le projet Heimdal disponible sur *http://www.github.com/DuneSt/* offre cette fonctionnalité. 
D'autres composants permettant d'interroger google ou twitter sont disponibles et utilisé dans le projet Steam.

@todo: ajouter URL projet Steam

+Aperçu du composant d'identification.>file://figures/Authentification.png|width=75|label=authentification+

!!!! Définition du composant

Nous définissons une nouvelle sous-classe de la classe ==WAComponent== et des accesseurs. Ce composant contient un login, un mot de passe ainsi que le composant qui l'a invoqué pour accéder à la partie administration.

[[[
WAComponent subclass: #TBAuthentificationComponent
   instanceVariableNames: 'password account component'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBAuthentificationComponent >> account
   ^ account
]]]

[[[
TBAuthentificationComponent >> account: anObject
   account := anObject
]]]

[[[
TBAuthentificationComponent >> password
   ^ password
]]]

[[[
TBAuthentificationComponent >> password: anObject
   password := anObject
]]]

[[[
TBAuthentificationComponent >> component
   ^ component
]]]

[[[
TBAuthentificationComponent >> component: anObject
   component := anObject
]]]

La variable d'instance ==component== sera initialisée par la méthode de classe suivante :

[[[
TBAuthentificationComponent class >> from: aComponent
   ^ self new
      component: aComponent;
      yourself
]]]


!!!! Rendu du composant

La méthode ==renderContentOn:== définit le contenu d'une boite de dialogue modale avec l'identifiant ==myAuthDialog==.
Il est composé d'une en-tête et d'un corps. Notez l'utilisation des messages ==tbsModal==, ==tbsModalBody:==, ==tbsModalContent:==  qui permettent une interaction modale avec ce composant.

[[[
TBAuthentificationComponent >> renderContentOn: html
   html tbsModal
      id: 'myAuthDialog';
      with: [
         html tbsModalDialog: [
            html tbsModalContent: [
               self renderHeaderOn: html.
               self renderBodyOn: html ] ] ]
]]]

L'en-tête affiche un titre avec de larges fontes. 

[[[
TBAuthentificationComponent >> renderHeaderOn: html
   html
      tbsModalHeader: [
         html tbsModalCloseIcon.
         html tbsModalTitle
            level: 4;
            with: 'Authentication' ]
]]]

Le corps du composant affiche un masque de saisie pour l'identifiant, le mot de passe
et finalement des boutons. 

[[[
TBAuthentificationComponent >> renderBodyOn: html
    html
        tbsModalBody: [
            html tbsForm: [
                self renderAccountFieldOn: html.
                self renderPasswordFieldOn: html.
                html tbsModalFooter: [ self renderButtonsOn: html ] ] ]
]]]


La méthode ==renderAccountFieldOn:== montre comment la valeur d'un input field est passée puis stockée dans une variable d'instance du composant quand l'utilisateur confirme sa saisie. Le paramètre de la méthode ==callback:== est un bloc qui prend lui-même un argument représentant la valeur du text input.

[[[
TBAuthentificationComponent >> renderAccountFieldOn: html
   html
      tbsFormGroup: [ html label with: 'Account'.
         html textInput
            tbsFormControl;
            callback: [ :value | account := value ];
            value: account ]
]]]

Le même procédé est utilisé pour le mot de passe.

[[[
TBAuthentificationComponent >> renderPasswordFieldOn: html
   html tbsFormGroup: [
      html label with: 'Password'.
      html passwordInput
         tbsFormControl;
         callback: [ :value | password := value ];
         value: password ]
]]]


Les boutons définissent par défaut le bouton nommé =='SignIn'== et son action est de vérifier l'adéquation 
entre le mot de passe et le compte.

[[[
TBAuthentificationComponent >> renderButtonsOn: html
   html tbsSubmitButton value: 'Cancel'.
   html tbsSubmitButton
      bePrimary;
      callback: [ self validate ];
      value: 'SignIn'
]]]

Lorsque l'utilisateur clique sur le bouton 'SignIn', le message ==validate== est envoyé.
Dans la méthode ==validate==, si le compte utilisé est valide (message ==isValidAccount:andPassword:==), nous indiquons au composant principal d'afficher la partie administration en lui envoyant le message ==gotoAdministration==.


Pour l'instant, notre méthode de validation de compte est simpliste puisque nous vérifions juste que le login est la chaîne 'admin' et le mot de passe 'password'.

[[[
TBAuthentificationComponent >> isValidAccount: login andPassword: passwd
   ^ login = 'admin' and: [ passwd = 'password' ]
	
TBAuthentificationComponent >> validate
   (self isValidAccount: self account andPassword: self password)	
      ifTrue: [ component gotoAdministration ]		
]]]

% !!!!! Améliorations
% Rechercher une autre méthode pour réaliser l'authentification de l'utilisateur (utilisation d'un backend de type base de données, LDAP ou fichier texte). En tout cas, ce n'est pas à la boite de login de faire ce travail, il faut le déléguer à un objet métier qui saura consulter le backend et authentifier l'utilisateur.
%
% De plus le composant ==TBAuthentificationComponent== pourrait afficher l'utilisateur lorsque celui-ci est logué.

!!!Intégration de l'authentification

Comme nous l'avons déjà évoqué, c'est depuis le composant (==TBPostsListComponent==) que nous donnons accès à la partie administration du site et au composant d'identification. Ce composant affiche une boîte modale, nous devons donc d'une part l'intégrer dans le composant ==TBPostsListComponent== mais également ajouter un lien qui déclenchera l'affichage de cette boîte modale c'est-à-dire le rendu du composant d'identification. 


Modifions donc la méthode ==renderContentOn:== du composant ==TBPostsListComponent== ainsi: 

[[[
TBPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   html render: (TBAuthentificationComponent from: self).
   html
      tbsContainer: [
         html tbsRow
            showGrid;
            with: [ self renderCategoryColumnOn: html.
                  self renderPostColumnOn: html ] ]
]]]

On définit également une méthode qui affiche un pictogramme clé et un lien 'SignIn'.
Lorsque l'utilisateur cliquera sur ce lien, la boîte modale ayant l'identifiant ==myAuthDialog== sera affichée.

[[[
TBPostsListComponent >> renderSignInOn: html
   html tbsGlyphIcon perform: #iconLock.
   html html: '<a data-toggle="modal" href="#myAuthDialog" class="link">SignIn</a>'
]]]

En rechargeant la page de TinyBlog dans votre navigateur, nous voyons maintenant le lien 'SignIn' et lorsque l'on clique dessus, nous obtenons bien le rendu sur la figure *@authentification*.


!!!Modélisation des administrateurs


 Avant cela, il faut enrichir notre modèle de Tinyblog avec la notion d'auteur.
 Le ou les auteur(s) associés à un blog pourront s'identifier pour administrer les posts.

 Le blog possède des auteurs qui peuvent écrire des posts. Un post n'a qu'un seul auteur (son créateur) même si tous les auteurs peuvent ensuite accéder et modifier n'importe quel post.

 Ajouter maintenant une classe nommée ==TBAuthor== sachant qu'un auteur est caractérisé par son pseudo (affiché publiquement dans le post), son login et son mot de passe.

 De même que pour les posts, ajoutez des accesseurs et des méthodes de création côté classe.
 Nous souhaitons pouvoir écrire dans un playground :

 [[[
 	luc := TBAuthor pseudo: 'Luke' login: 'luc' password: 'topsecret'
 ]]]

 Ajouter un champs ==author== dans la classe ==TBPost== ainsi que des accesseurs.
 Dans un playground, on souhaite pouvoir écrire :

 [[[
 	|luc|
 	luc := TBAdmin pseudo: 'Luke' login: 'luc' password: 'topsecret'.
 	(TBPost
 		title: 'Welcome in TinyBlog'
 		text: 'TinyBlog is a small blog engine made with Pharo.'
 		category: 'TinyBlog')
 		author: luc ;
 		yourself
 ]]]

 Dans la classe ==TBBlog==, ajouter une accesseur permettant de récupérer l'ensemble des auteurs du

!!!Gestion de session

Un objet session est attribué à chaque instance de l'application. Il permet de conserver principalement des informations qui sont partagées et accessible entre les composants. Une session est pratique pour gérer les informations de l'utilisateur en cours (identifié).  Nous allons voir comment nous l'utilisons pour gérer une connexion.

L'administrateur du blog peut vouloir voyager entre la partie privée et la partie publique de TinyBlog.

Nous définissons une nouvelle sous-classe de ==WASession== nommée ==TBSession==. Pour savoir si l'utilisateur s'est authentifié, nous devons définir un objet session et ajouter une variable d'instance contenant une valeur booléenne précisant l'état de l'utilisateur.

[[[
WASession subclass: #TBSession
    instanceVariableNames: 'logged'
    classVariableNames: ''
    package: 'TinyBlog-Components'
]]]

[[[
TBSession >> logged
    ^ logged

TBSession >> logged: anObject
    logged := anObject

TBSession >> isLogged
    ^ self logged
]]]

Il faut ensuite initialiser à `false` cette variable d'instance à la création d'une session.

[[[
TBSession >> initialize
    super initialize.
    self logged: false.
]]]

Dans la partie privée de TinyBlog, ajoutons un lien permettant le retour à la partie publique. Nous utilisons ici le message ==answer== puisque le composant d'administration a été appelé à l'aide du message ==call:==.

[[[
TBAdminComponent >> renderContentOn: html
    super renderContentOn: html.
    html tbsContainer: [
        html heading: 'Blog Admin'.
        html tbsGlyphIcon perform: #iconEyeOpen.
        html anchor
            callback: [ self answer ];
            with: 'Public Area'.
        html horizontalRule.
        html render: self report.
    ]
]]]

Dans l'espace public, il nous faut modifier le comportement du lien permettant d'accéder à l'administration. Il doit provoquer l'affichage de la boite d'authentification uniquement si l'utilisateur ne s'est pas encore connecté.

[[[
TBPostsListComponent >> renderSignInOn: html
    self session isLogged
        ifFalse: [
            html tbsGlyphIcon perform: #iconLock.
            html html: '<a data-toggle="modal" href="#myAuthDialog" class="link">SignIn</a>' ]
        ifTrue: [
            html tbsGlyphIcon perform: #iconUser.
            html anchor callback: [ self gotoAdministration ]; with: 'Private area' ]
]]]

Enfin, le composant ==TBAuthentificationComponent== doit mettre à jour la variable d'instance ==logged== de la session si l'utilisateur est bien un administrateur.

[[[
TBAuthentificationComponent >> validate
   (self account = 'admin' and: [ self password = 'password' ])
      ifTrue: [
         self session logged: true.
         component gotoAdministration ]
]]]


Il vous faut maintenant spécifier à Seaside qu'il doit utiliser l'objet ==TBSession== comme objet de session courant pour l'application TinyBlog.
Cette initialisation s'effectue dans la méthode ==initialize== de la classe ==TBApplicationRootComponent== que l'on modifie ainsi:

[[[
TBApplicationRootComponent class >> initialize
      "self initialize"
      | app |
      app := WAAdmin register: self asApplicationAt: 'TinyBlog'.
      app
         preferenceAt: #sessionClass put: TBSession.
      app
         addLibrary: JQDeploymentLibrary;
         addLibrary: JQUiDeploymentLibrary;
         addLibrary: TBSDeploymentLibrary
]]]

Pensez à exécuter cette méthode via ==TBApplicationRootComponent initialize== avant de tester à nouveau l'application.


