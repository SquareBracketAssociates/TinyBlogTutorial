!! Authentification et Session 

Le scénario assez classique que nous allons développer dans ce chapitre est le suivant : l'utilisateur doit s'authentifier pour accéder à la partie administration de TinyBlog. Il le fait à l'aide d'un compte et d'un mot de passe. 

La figure *@ApplicationArchitectureAdminHeader* montre un aperçu de l'architecture visée dans ce chapitre.

+Gérant l'authentification pour accéder à l'administration.>file://figures/ApplicationArchitectureAdminHeader.pdf|width=75|label=ApplicationArchitectureAdminHeader+

Nous commençons par mettre en place une première version permettant de naviguer entre la partie publique TinyBlog rendue par le composant
gérant la liste des bulletins (==TBPostsListComponent==) et une première version de la partie d'administration du site comme sur la figure *@SimpleAdminLink*.
Cela va nous permettre d'illustrer l'invocation de composant.

Nous intègrerons ensuite un composant d'identification sous la forme d'une boîte modale.
Cela va nous permettre d'illustrer comment la saisie de champs utilise de manière élégante les variables d'instances d'un composant.

Enfin, nous montrerons aussi comment stocker l'utilisateur connecté à l'aide d'une session.

!!! Composant d'administration simple (v1)

Définissons un composant d'administration très simple. Ce composant hérite de la classe ==TBScreenComponent== comme mentionné dans un chapitre précédent et illustré dans la figure *@ApplicationArchitectureAdminHeader*.

[[[
TBScreenComponent subclass: #TBAdminComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Nous définissons une première version de la méthode de rendu afin de pourvoir tester.

[[[
TBAdminComponent >> renderContentOn: html
   super renderContentOn: html.
   html tbsContainer: [
      html heading: 'Blog Admin'.
      html horizontalRule ]
]]]

!!! Ajout d'un bouton 'admin'

Nous souhaitons maintenant ajouter un bouton dans l'en-tête du site (composant ==TBHeaderComponent==) afin d'accéder à la partie administration du site comme sur la figure *@SimpleAdminLink*.
Pour cela, nous allons modifier les composants existants ==TBHeaderComponent== (en-tête) et ==TBPostsListComponent== (partie publique).

+Lien simple vers la partie administration.>file://figures/SimpleAdminLink.png|width=100|label=SimpleAdminLink+

Commençons par ajouter le 'admin' dans l'en-tête:

[[[
TBHeaderComponent >>	renderContentOn: html	
		html tbsNavbar beDefault; with: [  
			 html tbsContainer: [ 
				self renderBrandOn: html.	
				self renderButtonsOn: html
		]]
]]]

[[[
TBHeaderComponent >>	renderButtonsOn: html
	html form: [ 
	html tbsNavbarButton 
		tbsPullRight;
		with: 'Admin' ]
]]]

Si vous rafraichissez votre navigateur, le bouton admin est bien présent mais il n'a aucun effet pour l'instant.
Il faut définir un ==callback:== sur ce bouton (un bloc) qui remplace le composant courant (==TBPostsListComponent==) par le composant d'administration (==TBAdminComponent==).

Commençons par réviser la définition de ==TBHeaderComponent== en lui ajoutant une variable d'instance ==component== pour stocker et accéder au composant courant ainsi :

[[[
WAComponent subclass: #TBHeaderComponent
	instanceVariableNames: 'component'
	classVariableNames: ''
	package: 'TinyBlog-Components'
]]]

[[[
TBHeaderComponent >> component: anObject
   component := anObject
	
TBHeaderComponent >> component
   ^ component
]]]

[[[
TBHeaderComponent >> from: aComponent
   ^ self new
		component: aComponent;
		yourself
]]]

Modifions l'instanciation de ce composant en-tête dans ==TBScreenComponent== ainsi :

[[[
TBScreenComponent >> createHeaderComponent
	^ TBHeaderComponent from: self
]]]

Nous pouvons maintenant ajouter le ==callback:== sur le bouton :

[[[
TBHeaderComponent >>	renderButtonsOn: html
	html form: [ 
	html tbsNavbarButton 
		tbsPullRight;
		callback: [ component gotoToAdministration ]; 
		with: 'Admin' ]
]]]

Il ne reste plus qu'à définir la méthode ==gotoToAdministration== sur le composant ==TBPostsListComponent== :

[[[
TBPostsListComponent >> gotoToAdministration
   self call: TBAdminComponent new
]]]

Si vous rafraichissez votre navigateur et cliquez sur le bouton 'Admin', vous devez voir la partie administraion v1 s'afficher.
Toutefois, ce bouton admin est toujours présent dans la partie administration bien qu'il n'est plus fonctionnel.

!!! Ajout d'un bouton 'disconnect'

Nous souhaitons maintenant remplacer le composant en-tête par un autre lorsqu'on affiche la partie administration.
Cette nouvelle en-tête affichera un bouton 'disconnect'.

Définissons un nouveau composant en-tête:
[[[	
TBHeaderComponent subclass: #TBAdminHeaderComponent
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'TinyBlog-Components'
]]]

[[[
TBAdminHeaderComponent >> renderButtonsOn: html
	html form: [ 
		html tbsNavbarButton 
			tbsPullRight; 
			callback: [ component gotoToPublic ];
			with: 'Disconnect' ]
]]]

Indiquons au composant ==TBAdminComponent== d'utiliser cette en–tête:

[[[
TBAdminComponent >> createHeaderComponent
   ^ TBAdminHeaderComponent from: self; yourself
]]]

[[[
TBAdminComponent >> gotoToPublic
	self answer
]]]

Si vous rafraichissez votre navigateur et cliquez sur le bouton 'Admin', vous devez voir la partie administraion v1 s'afficher avec un bouton 'disconnect' pour revenir à la partie publique


!!! call:/answer:

Si vous étudiez le code précédent, vous verrez que nous avons utilisé le mécanisme ==call:==/==answer:== de Seaside pour mettre en place la navigation entre les composants ==TBPostsListComponent== et ==TBAdminComponent==.
Ce mécanisme puissant et élégant est expliqué dans la vidéo 1 de la semaine 5 du Mooc.

@todo ré-expliquer ?

!!! Composant d'identification

Développons maintenant un composant d'identification qui lorsqu'il sera invoqué ouvrira une boite de dialogue pour demander un login et un mot de passe. Le résultat que nous voulons obtenir est montré sur la figure *@authentification*. Une telle fonctionnalité devrait faire partie d'une bibliothèque de composants de base en Seaside. Le projet Heimdal disponible sur *http://www.github.com/DuneSt/* offre cette fonctionnalité. 
D'autres composants permettant d'interroger google ou twitter sont disponibles et utilisé dans le projet Steam.

@todo: ajouter URL projet Steam

+Aperçu du composant d'identification.>file://figures/Authentification.png|width=75|label=authentification+

!!!! Définition d'un composant d'identification

Nous définissons une nouvelle sous-classe de la classe ==WAComponent== et des accesseurs. Ce composant contient un login, un mot de passe ainsi que le composant qui l'a invoqué pour accéder à la partie administration.

[[[
WAComponent subclass: #TBAuthentificationComponent
   instanceVariableNames: 'password account component'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBAuthentificationComponent >> account
   ^ account
]]]

[[[
TBAuthentificationComponent >> account: anObject
   account := anObject
]]]

[[[
TBAuthentificationComponent >> password
   ^ password
]]]

[[[
TBAuthentificationComponent >> password: anObject
   password := anObject
]]]

[[[
TBAuthentificationComponent >> component
   ^ component
]]]

[[[
TBAuthentificationComponent >> component: anObject
   component := anObject
]]]

La variable d'instance ==component== sera initialisée par la méthode de classe suivante :

[[[
TBAuthentificationComponent class >> from: aComponent
   ^ self new
      component: aComponent;
      yourself
]]]


!!!! Rendu du composant

La méthode ==renderContentOn:== définit le contenu d'une boite de dialogue modale avec l'identifiant ==myAuthDialog==.
Il est composé d'une en-tête et d'un corps. Notez l'utilisation des messages ==tbsModal==, ==tbsModalBody:==, ==tbsModalContent:==  qui permettent une interaction modale avec ce composant.

[[[
TBAuthentificationComponent >> renderContentOn: html
   html tbsModal
      id: 'myAuthDialog';
      with: [
         html tbsModalDialog: [
            html tbsModalContent: [
               self renderHeaderOn: html.
               self renderBodyOn: html ] ] ]
]]]

L'en-tête affiche un titre avec de larges fontes. 

[[[
TBAuthentificationComponent >> renderHeaderOn: html
   html
      tbsModalHeader: [
         html tbsModalCloseIcon.
         html tbsModalTitle
            level: 4;
            with: 'Authentication' ]
]]]

Le corps du composant affiche un masque de saisie pour l'identifiant, le mot de passe
et finalement des boutons. 

[[[
TBAuthentificationComponent >> renderBodyOn: html
    html
        tbsModalBody: [
            html tbsForm: [
                self renderAccountFieldOn: html.
                self renderPasswordFieldOn: html.
                html tbsModalFooter: [ self renderButtonsOn: html ] ] ]
]]]


La méthode ==renderAccountFieldOn:== montre comment la valeur d'un input field est passée puis stockée dans une variable d'instance du composant quand l'utilisateur confirme sa saisie. Le paramètre de la méthode ==callback:== est un bloc qui prend lui-même un argument représentant la valeur du text input.

[[[
TBAuthentificationComponent >> renderAccountFieldOn: html
   html
      tbsFormGroup: [ html label with: 'Account'.
         html textInput
            tbsFormControl;
            callback: [ :value | account := value ];
            value: account ]
]]]

Le même procédé est utilisé pour le mot de passe.

[[[
TBAuthentificationComponent >> renderPasswordFieldOn: html
   html tbsFormGroup: [
      html label with: 'Password'.
      html passwordInput
         tbsFormControl;
         callback: [ :value | password := value ];
         value: password ]
]]]


Les boutons définissent par défaut le bouton nommé =='SignIn'== et son action est de vérifier l'adéquation 
entre le mot de passe et le compte.

[[[
TBAuthentificationComponent >> renderButtonsOn: html
   html tbsSubmitButton value: 'Cancel'.
   html tbsSubmitButton
      bePrimary;
      callback: [ self validate ];
      value: 'SignIn'
]]]

Lorsque l'utilisateur clique sur le bouton 'SignIn', le message ==validate== est envoyé.
Dans la méthode ==validate==, si le compte utilisé est valide (message ==isValidAccount:andPassword:==), nous indiquons au composant principal d'afficher la partie administration en lui envoyant le message ==gotoAdministration==.

Pour l'instant, notre méthode de validation de compte est simpliste puisque nous vérifions juste que le login est la chaîne 'admin' et le mot de passe 'password'.

[[[
TBAuthentificationComponent >> isValidAccount: login andPassword: passwd
   ^ login = 'admin' and: [ passwd = 'password' ]
]]]

[[[
TBAuthentificationComponent >> validate
   (self isValidAccount: self account andPassword: self password)	
      ifTrue: [ component gotoAdministration ]		
]]]

% !!!!! Améliorations
% Rechercher une autre méthode pour réaliser l'authentification de l'utilisateur (utilisation d'un backend de type base de données, LDAP ou fichier texte). En tout cas, ce n'est pas à la boite de login de faire ce travail, il faut le déléguer à un objet métier qui saura consulter le backend et authentifier l'utilisateur.
%
% De plus le composant ==TBAuthentificationComponent== pourrait afficher l'utilisateur lorsque celui-ci est logué.

@todo Luc Here
!!!Intégration du composant d'identification


TBHeaderComponent >> renderButtonsOn: html
html render: (TBAuthentificationComponent from: component).
html tbsNavbarButton 
	tbsPullRight; 
	attributeAt: 'data-target' put: '#myAuthDialog';
	attributeAt: 'data-toggle' put: 'modal';
	with: 'Admin'



Comme nous l'avons déjà évoqué, c'est depuis le composant (==TBPostsListComponent==) que nous donnons accès à la partie administration du site et au composant d'identification. Ce composant affiche une boîte modale, nous devons donc d'une part l'intégrer dans le composant ==TBPostsListComponent== mais également ajouter un lien qui déclenchera l'affichage de cette boîte modale c'est-à-dire le rendu du composant d'identification. 


Modifions donc la méthode ==renderContentOn:== du composant ==TBPostsListComponent== ainsi: 

[[[
TBPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   html render: (TBAuthentificationComponent from: self).
   html
      tbsContainer: [
         html tbsRow
            showGrid;
            with: [ self renderCategoryColumnOn: html.
                  self renderPostColumnOn: html ] ]
]]]

On définit également une méthode qui affiche un pictogramme clé et un lien 'SignIn'.
Lorsque l'utilisateur cliquera sur ce lien, la boîte modale ayant l'identifiant ==myAuthDialog== sera affichée.

[[[
TBPostsListComponent >> renderSignInOn: html
   html tbsGlyphIcon perform: #iconLock.
   html html: '<a data-toggle="modal" href="#myAuthDialog" class="link">SignIn</a>'
]]]

En rechargeant la page de TinyBlog dans votre navigateur, nous voyons maintenant le lien 'SignIn' et lorsque l'on clique dessus, nous obtenons bien le rendu sur la figure *@authentification*.


!!!Modélisation des administrateurs

Pour l'instant, le login et le mot de passe pour accéder à la partie administration sont directement stockés dans le code du composant ==TBAuthentificationComponent== . 
Nous allons maintenant changer cela et stocker ces identifiants dans la base de données.

Commençons par enrichir notre modèle de Tinyblog avec la notion d'administrateur.
Un blog possède un administrateur qui peut s'identifier sur le blog afin administrer les posts qu'il contient. Ajoutons donc une nouvelle classe nommée ==TBAdministrator== caractérisé par son pseudo, son login et son mot de passe.

[[[
Object subclass: #TBAdministrator
	instanceVariableNames: 'login password'
	classVariableNames: ''
	package: 'TinyBlog'.

TBAdministrator >> login
   ^ login

TBAdministrator >> login: anObject
   login := anObject

TBAdministrator >> password
   ^ password

TBAdministrator >> password: anObject
   password := (MD5 hashMessage: anObject)

TBAdministrator class >> login: login password: password
	^ self new 
		login: login;
		password: password;
		yourself	
]]]


Dans un playground, on peut inspecter l'expression suivante :

[[[
luc := TBAdmin login: 'luc' password: 'topsecret'.
]]] 

@todo
password are not stored directly.
we store the MD5 of the password.


Ajoutons un champ ==adminUser== dans la classe ==TBBlog== afin d'y stocker l'administrateur du blog:

[[[
Object subclass: #TBBlog
	instanceVariableNames: 'adminUser posts'
	classVariableNames: ''
	package: 'TinyBlog'.

TBBlog >> administrator
   ^ adminUser
	
TBBlog >> initialize
   super initialize.
   posts := OrderedCollection new.
   adminUser := self createAdministrator
		
TBBlog >> createAdministrator
   ^ TBAdministrator login: self class defaultAdminLogin password: self class defaultAdminPassword
	
TBBlog class >> defaultAdminLogin
   ^ 'admin'

TBBlog class >> defaultAdminPassword
   ^ 'topsecret'
]]] 
 
Il ne faut pas oublier de re-créer le blog ainsi:

[[[
	TBBlog reset; createDemos
]]]
 
!!!Modification de l'authentification

Modifions maintenant le composant d'authentification ==TBAuthentificationComponent== pour qu'il utilise les valeurs d'identification du blog courant.  

[[[
TBAuthentificationComponent >> isValidAccount: login andPassword: passwd
   ^ login = component blog administrator login and: [ 
			(MD5 hashMessage: passwd) = component blog administrator password ]
]]]


@todo here

!!!Gestion de session

Un objet session est attribué à chaque instance de l'application. Il permet de conserver principalement des informations qui sont partagées et accessible entre les composants. Une session est pratique pour gérer les informations de l'utilisateur en cours (identifié).  Nous allons voir comment nous l'utilisons pour gérer une connexion.

L'administrateur du blog peut vouloir voyager entre la partie privée et la partie publique de TinyBlog.

Nous définissons une nouvelle sous-classe de ==WASession== nommée ==TBSession==. Pour savoir si l'utilisateur s'est authentifié, nous devons définir un objet session et ajouter une variable d'instance contenant une valeur booléenne précisant l'état de l'utilisateur.

[[[
WASession subclass: #TBSession
    instanceVariableNames: 'logged'
    classVariableNames: ''
    package: 'TinyBlog-Components'
]]]

[[[
TBSession >> logged
    ^ logged

TBSession >> logged: anObject
    logged := anObject

TBSession >> isLogged
    ^ self logged
]]]

Il faut ensuite initialiser à `false` cette variable d'instance à la création d'une session.

[[[
TBSession >> initialize
    super initialize.
    self logged: false.
]]]

Dans la partie privée de TinyBlog, ajoutons un lien permettant le retour à la partie publique. Nous utilisons ici le message ==answer== puisque le composant d'administration a été appelé à l'aide du message ==call:==.

[[[
TBAdminComponent >> renderContentOn: html
    super renderContentOn: html.
    html tbsContainer: [
        html heading: 'Blog Admin'.
        html tbsGlyphIcon perform: #iconEyeOpen.
        html anchor
            callback: [ self answer ];
            with: 'Public Area'.
        html horizontalRule.
        html render: self report.
    ]
]]]

Dans l'espace public, il nous faut modifier le comportement du lien permettant d'accéder à l'administration. Il doit provoquer l'affichage de la boite d'authentification uniquement si l'utilisateur ne s'est pas encore connecté.

[[[
TBPostsListComponent >> renderSignInOn: html
    self session isLogged
        ifFalse: [
            html tbsGlyphIcon perform: #iconLock.
            html html: '<a data-toggle="modal" href="#myAuthDialog" class="link">SignIn</a>' ]
        ifTrue: [
            html tbsGlyphIcon perform: #iconUser.
            html anchor callback: [ self gotoAdministration ]; with: 'Private area' ]
]]]

Enfin, le composant ==TBAuthentificationComponent== doit mettre à jour la variable d'instance ==logged== de la session si l'utilisateur est bien un administrateur.

[[[
TBAuthentificationComponent >> validate
   (self account = 'admin' and: [ self password = 'password' ])
      ifTrue: [
         self session logged: true.
         component gotoAdministration ]
]]]


Il vous faut maintenant spécifier à Seaside qu'il doit utiliser l'objet ==TBSession== comme objet de session courant pour l'application TinyBlog.
Cette initialisation s'effectue dans la méthode ==initialize== de la classe ==TBApplicationRootComponent== que l'on modifie ainsi:

[[[
TBApplicationRootComponent class >> initialize
      "self initialize"
      | app |
      app := WAAdmin register: self asApplicationAt: 'TinyBlog'.
      app
         preferenceAt: #sessionClass put: TBSession.
      app
         addLibrary: JQDeploymentLibrary;
         addLibrary: JQUiDeploymentLibrary;
         addLibrary: TBSDeploymentLibrary
]]]

Pensez à exécuter cette méthode via ==TBApplicationRootComponent initialize== avant de tester à nouveau l'application.


