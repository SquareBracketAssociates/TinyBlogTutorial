! Utiliser des modèles de mise en page avec Mustache (draft)

Poursuivons l'amélioration de TinyBlog en nous intéressant à l'utilisation de modèles pour l'affichage des données de TinyBlog.
L'idée de ce chapitre est de vous montrer comment on peut utiliser Mustache pour l'utilisation de templates. 

!! Ajouter un footer

L'objectif est d'ajouter un bas de page à l'écran principal de TinyBlog. Cette zone est généralement destiné à recevoir les mentions légales d'un site, des liens, les noms des auteurs et de nombreuses autres informations. Pour constituer ces blocs de texte, le framework Mustache va être particulièrement utile puisqu'il va nous permettre de mixer aisément de nombreuses chaines de caractères avec des balises HTML et ceci, sans avoir recours à une pénible manipulation des chaines de caractères. 

!! Ajouter un bas de page

Pour mettre en place le bas de page, il nous faut tout d'abord ajouter la méthode ==renderFooterOn:== chargée de l'affichage du bas de page. Vous devez bien évidemment modifier la méthode ==renderContentOn:== de la classe ==TBPostListComponent== en ajoutant l'appel à la méthode ==renderFooterOn:==.

[[[
TBPostListComponent >> renderFooterOn: html
 	html div class: 'footer'; with: [
		html text: 'I''am the footer!'
	].
]]]


[[[
TBPostListComponent >> renderContentOn: html
	super renderContentOn: html.
	html render: (TBAuthentificationComponent from: self).
	html
		tbsContainer: [ 
			html tbsRow
				showGrid;
				with: [ 
					self renderCategoryColumnOn: html.
					self renderPostColumnOn: html
			]. 
			self renderFooterOn: html 		
		]
]]]

Le style de la ==div== contenant le bas de page a été modifié à l'aide d'une classe CSS nommée ==footer==. Celle ci va nous permettre de spécifier le style d'affichage du bas de page. Pour cela, ajoutez un appel à la méthode ==applyFooterStyleOn:== à la déclaration de la feuille de styles.

[[[
TBApplicationRootComponent >> styleSheet
	| styles |
	styles := CascadingStyleSheetBuilder new.
	self 
		applyTitleStyleOn: styles;
		applyParagraphSubtitleStyleOn: styles;
		applyParagraphContentStyleOn: styles;
		applyFooterStyleOn: styles.
	^styles build asString
]]]

Cette méthode sélectionne les éléments de la classe ==footer== et applique sur eux le style défini par une autre méthode nommée ==footerStyleOn:==. 

[[[
TBApplicationRootComponent >> applyFooterStyleOn: aSheet
	^aSheet declareRuleSetFor: [ :selector | selector div class: 'footer' ]
			with: [ :style | self footerStyleOn: style ]
]]]

La méthode ==footerStyleOn:== fixe les attributs CSS afin de placer la ==div== en bas de la page. Un fond gris est appliqué et le texte est centré.

[[[
TBApplicationRootComponent >> footerStyleOn: aStyle
	aStyle
		position: CssConstants absolute;
		bottom: 0 pixels;
		paddingTop: 25 pixels;
		height: 150 pixels;
		width: 100 percent;
		backgroundColor: (CssRGBColor red: 239 green: 239 blue: 239);
		textAlign: CssConstants center;
		yourself
]]]

!! Ajouter du contenu dans le bas de page

Pour ajouter des élément dans le bas de page, vous allez utiliser certains fonctionnalités de Mustache qui facilitent grandement la substitution d'éléments au sein de modèles. Bien évidemment, vous pourriez également utilisation les méthodes de manipulation de chaînes de caractères présentes dans Pharo mais le travail serait bien plus complexe et surtout bien moins lisible. Utiliser Mustage simplifie donc grandement la maintenance de votre code.

!!! Utiliser du texte statique

Le premier élément doit afficher les principales technologies utilisées dans TinyBlog. Pour cela, définissez une méthode ==renderPoweredByOn:== dans la classe TBScreenComponent. Un dictionaire contient les données qui sont insérées au sein du modèle. Celui-ci est définit par une chaîne de caractères où les éléments devant être substitués sont encadrés par les caractères "{{" et "}}". Par défaut, Mustache utilise les caractères spéciaux d'HTML pour assurer un rendu web optimal (par exemple '<b>Pharo</b>' est transformé en '&lt;b&gt;Pharo&lt;/b&gt;'). Si vous ne voulez pas les utiliser, vous devez encadrer les éléments par les caractères "{{{" et "}}}".

[[[
TBScreenComponent >> renderPoweredByOn: html
	html text: ('Powered by {{language}}, {{framework}} and {{tool}}.' asMustacheTemplate value: { 
		'language' -> 'Pharo'. 
		'framework' -> 'Seaside'.
		'tool' -> 'Bootstrap'
	} asDictionary)
]]]

Vous pouvez maintenant modifier la méthode ==renderFooterOn:== afin d'afficher le texte sur la page.

[[[
TBScreenComponent >> renderFooterOn: html
 	html div class: 'footer'; with: [
		self renderPoweredByOn: html.
	]
]]]

!!! Utiliser du texte généré dynamiquement

Avec Mustache, il est également possible de remplacer des éléments au sein d'un modèle à l'aide de texte généré dynamiquement. Par exemple, à l'aide de la méthode ==renderDateTodayOn:==, TinyBlog peut construire un texte contenant la date du jour. Le code exécuté doit être placé entre crochets au sein du dictionnaire définissant les données à insérer.

[[[
TBScreenComponent >> renderDateTodayOn: html
	html 
		text: ('The date today is {{today}}.' asMustacheTemplate 
		value: { 'today' -> [ Date today ] } asDictionary)
]]]

Pour que la date apparaisse sur la page, il vous faut ajoute l'appel à la méthode ==renderFooterOn:==.

[[[
TBScreenComponent >> renderFooterOn: html
	html div class: 'footer'; with: [
		self renderDateTodayOn: html.
		html break.
		self renderPoweredByOn: html.
	]
]]]


[[[
'{{language}} is cool' asMustacheTemplate value: { 
    'language' -> 'Pharo' 
} asDictionary
]]]


{{{<b>Pharo</b>}}} : pour ne pas obtenir une séquence de caractères encodée ('<b>Pharo</b> is cool') sinon '&lt;b&gt;Pharo&lt;/b&gt; is cool'

!!! Affichage conditionnel

[[[
'Pharo {{#visible}}is cool{{/visible}}' asMustacheTemplate value: { 
	'language' -> '<b>Pharo</b>'.
	'visible' -> true 
} asDictionary.
]]]

Affiche autant de fois qu'il y a de membres dans la collection du contexte
[[[
'Pharo is {{#list}}wow {{/list}}' asMustacheTemplate value: { 
	'list' -> { 1. 2. 3.}
} asDictionary.
]]]


!!! Affichage de n éléments

[[[
'My prefered programming languages are {{#list}}{{language}} {{/list}}' asMustacheTemplate value: { 
	'list' -> { 
		{ 'language' -> 'Pharo'} asDictionary.
		{ 'language' -> 'Smalltalk'} asDictionary.
		{ 'language' -> 'Forth'} asDictionary.
	}
} asDictionary.
]]]


!!! Exécution de blocs de code

[[[
'{{language}} is great' asMustacheTemplate value: { 'language' -> [ 'pharo' asUppercase ] } asDictionary
]]]


Les blocs peuvent recevoir un paramètre
[[[
'{{#wrapped}} {{name}} is awesome {{/wrapped}}' asMustacheTemplate
    value: {
        'name' -> 'Willy'.
        'wrapped' -> [ :render | '<b>', render value, '</b>' ] } asDictionary.
]]]


!!! Sections inversées 

Elles s'affichent si la clé n'existe pas

[[[
'list{{^ list }} is {{/ list}}displayed' asMustacheTemplate
    value: { 'list' -> { 1 } } asDictionary.
--> 'listdisplayed'
]]]

!!! Templates partiels (sous modèles)

