! TinyBlog: Préparation

+Some caption>file://figures/BrowseApplications.png|width=50+

Ce tutorial va vous enseigner comment definir et deployer une application en utilisant Pharo/Seaside/Mongo ainsi que des frameworks disponibles en Pharo comme NeoJSON.
Nous allons définir un mini moteur de blogs. Les solutions proposées dans le tutorial sont parfois non optimale afin de vous faire réagir et que vous puissiez proposer d'autres solutions et améliorations.

D'autre part, notre objectif n'est pas d'être exhaustif. Nous montrons une facon de faire cependant nous invitons le lecteur à lire les références sur les autres chapitres, livres et tutoriaux afin d'approfondir son exp\'ertise.


!! Installation et préparation de Pharo

!!! Créer un projet sur SmalltalkHub
 
- Depuis votre compte créer un projet sur http://smalltalkhub.com
-- Nommez le "TinyBlog",
-- Récupérer l'URL du projet: 'http://smalltalkhub.com/mc/XXX/TinyBlog/main''

!!! Mettre en place Pharo

- Télécharger Pharo 4.0 à partir du site pharo.org
- A partir du "Configuration Browser", installer les paquets:
-- Seaside3,
-- VoyageMongo,
-- BootstrapMagritte,
-- Mustache
- Créez un paquet nommé TinyBlog,
- Créez un paquet nommé TinyBlog-Tests

!!! Créer la configuration du projet

- Créer un projet avec Versionner
-- Créer un nouveau projet "TinyBlog",
-- Dans development, ajoutez les paquets dont votre projet dépend:
--- Seaside3,
--- VoyageMongo,
--- BootstrapMagritte,
--- Mustache
-- Dans Packages, ajoutez le paquet TinyBlog,
--- Définissez son repository: 'http://smalltalkhub.com/mc/XXX/TinyBlog/main'
--- Cliquer sur le bouton "Save to development"

!!! Démarrer le serveur HTTP

- Aller dans Tools pour ouvrir le Seaside Control Panel,
- Faire un clic droit dans la partie supérieure et sélectionner le ZnZinServerAdaptor,
- Choisir le port 8080,
- Cliquer sur le serveur pour le sélectionner et cliquez sur le bouton "Start".











! Le modèle de TinyBlog

Le modèle de tinyblog est extremement simple: Les deux classes ==TBPost== et  ==TBBlog==.
Notez que comme nous le verrons plus tard, nous allons utiliser le fait que Voyage offre une base de données en mémoire.


!!! La classe TBPost

[[[
Object subclass: #TBPost
   instanceVariableNames: 'title text date category visible'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

!!! Description d'un post

Cinq variables d'instance pour décrire un post sur le blog.

[[[
|Variable      |Signification                |
|--------------|-----------------------------|
|title         |Titre du post                |
|text          |Texte du post                |
|date          |Date de redaction            |
|category      |Rubrique contenant le post   |
|visible       |Post visible ou pas ?        |
]]]

Ces variables ont des setters et getters dans le protocole accessing.

[[[
TBPost >> title
   ^ title

TBPost >> title: anObject
   title := anObject

TBPost >> text
   ^ text

TBPost >> text: anObject
   text := anObject

TBPost >> date
   ^ date

TBPost >> date: anObject
   date := anObject

TBPost >> visible
   ^ visible

TBPost >> visible: anObject
   visible := anObject

TBPost >> category
   ^ category

TBPost >> category: anObject
   category := anObject
]]]

!!!! Gérer la visibilité d'un post

Il faut avoir la possibilité d'indiquer qu'un post est visible ou pas. Il faut également pouvoir demandé à un post s'il est visible. Les méthodes sont définies dans la protocole 'action'.

[[[
TBPost >> beVisible
   self visible: true

TBPost >> notVisible
   self visible: false

TBPost >> isVisible
   ^ self visible
]]]




!!!! Initialisation

La méthode 'initialize' (protocole ==initialize-release==) fixe par défaut la date et fixe par défaut la visibilité à false (l'utilisateur devra par la suite activer la visibilité ce qui permet de rédiger des brouillons et de publier lors que le post est terminé). Un post est également rangé par défaut dans la catégorie "Unclassified" que l'on définit au niveau classe. 

[[[
TBPost class >> unclassifiedTag
   ^ 'Unclassified'
]]]

[[[
TBPost >> initialize
  self category: TBPost unclassifiedTag.
  self date: Date today.
  self visible: false.
]]]


!!!! Amélioration
Il serait préférable de ne pas faire une référence en dur à la class ==TBPost== comme dans la méthode ==initialize==.
Proposer une solution.


!!!! Instance création API

Coté classe, on définit que ==TBPost== est un objet géré par Voyage et on spécifie des méthodes pour faciliter la création de post appartenant ou pas à une catégorie. La méthode ==unclassifiedTag== renvoie une valeur indiquant que le post n'est pas rangé dans une catégorie.


[[[
TBPost class >> title: aTitle text: aText
   ^ self new
        title: aTitle;
        text: aText;
        yourself

TBPost class >> title: aTitle text: aText category: aCategory
   ^ (self title: aTitle text: aText)
            category: aCategory;
            yourself
]]]


!!!! Test

Savoir si un post est classé dans une catégorie

[[[
TBPost >> isUnclassified
   ^ self category = TBPost unclassifiedTag
]]]

Il serait préférable de ne pas faire une référence en dur à la class TBPost.
Proposer une solution.

#001-TinyBlog-BGPost-StephaneDucasse.1






!!! La classe TBBlog
La classe ==TBBlog== collecte les posts. Nous allons développer ==TBBlog== en écrivant des tests puis les implémentant. 

[[[
Object subclass: #TBBlog
   instanceVariableNames: 'posts'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Ici nous definissons le fait que la base de donnée fonctionne en mémoire par l'utilisation de ==VOMemoryRepository new==.
[[[
TBBlog >> initialize
   super initialize.
   posts := OrderedCollection new. 
]]]



!!!! Une seule base

Il y a une seule instance de la classe (singleton) et celle-ci est construite coté classe comme suit.

[[[
TBBlog class
   instanceVariableNames: 'uniqueInstance'

TBBlog class >> reset
   uniqueInstance := nil

TBBlog class >> current
   "answer the instance of the TBRepository"
   ^ uniqueInstance ifNil: [ uniqueInstance := self new ]

TBBlog class >> initialize
   self reset
]]]


!! Tester les règles métiers
Nous allons écrire les tests pour les règles métiers et ceci en mode TDD (Test Driven Development) c'est-à-dire en développant les tests en premiers puis en définissant les fonctionalités jsuqu'à ce que les tests passent.

Les tests unitaires sont regroupés dans le paquet ==TinyBlog-tests== qui contient la classe ==TBBlogTest==.

[[[
TestCase subclass: #TBBlogTest
   instanceVariableNames: 'blog post first'
   classVariableNames: ''
   category: 'TinyBlog-Tests'
]]]

Avant le lancement des tests, la méthode ==setUp== initialise la connexion vers la base, efface son contenu, ajoute un post et en crée un autre qui provisoirement n'est pas enregistré.

[[[
TBBlogTest >> setUp
   blog := TBBlog current.
   blog removeAll.
   
   first := (TBPost title: 'A title' text: 'A text' category: 'First Category').
   blog writeBlogPost: first.
   
   post := (TBPost title: 'Another title' text: 'Another text' category: 'Second Category') beVisible
]]]

On en profite pour tester différentes configuration. Les posts ne sont pas dans la même catégorie, l'un est visible, l'autre pas.

La méthode ==tearDown== exécutée au terme des tests remet à zéro la connexion.

[[[
TBBlogTest >> tearDown
   TBBlog reset
]]]

Noter que si vous deployer un blog puis executer les tests vous perdrez les postes que vous avez crées car nous les remettons à zéro.

Nous allons développer les tests d'abord puis ensuite passer à l'implémentation
des fonctionalités.

!!!! Un premier test

[[[
TBBlogTest >> testAddBlogPost
   blog writeBlogPost: post.
   self assert: blog size equals: 2
]]]

Ce test ne marche pas car nous n'avons pas défini ==writeBlogPost:== et ==removeAll==.

[[[
TBBlog >> removeAll
   posts := OrderedCollection new
]]]

[[[
TBBlog >> writeBlogPost: aPost
   "Write the blog post in database"
   posts add: aPost
]]]

[[[
TBBlog >> size
   ^ posts size
]]]

Le test précédent doit maintenant passer.

Ecrivons un test pour couvrir les fonctionalités que nous venons de développer. 

!!!! Obtenir le nombre de posts dans la base


[[[
TBBlogTest >> testSize
   self assert: blog size equals: 1
]]]

!!!! Effacer l'intégralité des posts

[[[
TBBlogTest >> testRemoveAllBlogPosts
   blog removeAll.
   self assert: blog size equals: 0.
]]]


!!! Quelques autres fonctionalités

Nous définissons les fonctionalités et nous assurons que les tests passent. 
Les règles métiers sont regroupées dans le protocole 'action' de la classe ==TBBlog==.

!!!! Obtenir l'ensemble des posts (visibles et invisibles)


[[[
TBBlogTest >> testAllBlogPosts
   blog writeBlogPost: post.
   self assert: (blog allBlogPosts) size equals: 2.
]]]

[[[
TBBlog >> allBlogPosts
   ^ posts
]]]


!!!! Obtenir tous les posts visibles

[[[
TBBlogTest >> testAllVisibleBlogPosts
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPosts) size equals: 1.
]]]

[[[
TBBlog >> allVisibleBlogPosts
   ^ posts select: [ :p | p isVisible ]
]]]


!!!! Obtenir tous les posts d'une catégorie

[[[
TBBlogTest >> testAllBlogPostsFromCategory
   self assert: (blog allBlogPostsFromCategory: 'First Category') size equals: 1
]]]

[[[
TBBlog >> allVisibleBlogPostsFromCategory: aCategory
   ^ posts select: [ :p | p category = aCategory and: [ p isVisible ]]
]]]


!!!! Obtenir tous les posts visibles d'une catégorie

[[[
TBBlogTest >> testAllVisibleBlogPostsFromCategory
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPostsFromCategory: 'First Category') size equals: 0.
   self assert: (blog allVisibleBlogPostsFromCategory: 'Second Category') size equals: 1.
]]]

[[[
TBBlog >> allBlogPostsFromCategory: aCategory
   ^ posts select: [ :p | p category = aCategory ]
]]]

!!!! Vérifier la gestion des posts non classés

[[[
TBBlogTest >> testUnclassifiedBlogPosts
   self assert: (blog allBlogPosts select: [ :p | p isUnclassified ]) size equals: 0.
]]]

!!!! Obtenir la liste des catégories

[[[
TBBlogTest >> testAllCategories
   blog writeBlogPost: post.
   self assert: (blog allCategories) size equals: 2.
]]]

[[[
TBBlog >> allCategories
   ^(self allBlogPosts collect: [ :p | p category ]) asSet
]]]

!! Futures Evolutions

Plusieurs évolutions peuvent être apportées telles que obtenir uniquement la liste des catégories contenant au moins un post visible, effacer une catégorie et les posts contenus, renommer un catégorie, déplacer un post d'une catégorie à une autre, rendre visible ou invisible une catégorie et son contenu, etc. Nous vous encourageons à les développer.

Afin de nous aider à tester l'application nous définissons quelques postes. 

[[[
TBBlog class >> createDemoPosts
   "TBBlog createDemoPosts"
   self current 
      writeBlogPost: ((TBPost title: 'Welcome in TinyBlog' text: 'TinyBlog is a small blog engine made with Pharo.' category: 'TinyBlog') visible: true);
      writeBlogPost: ((TBPost title: 'Report Pharo Sprint' text: 'Friday, June 12 there was a Pharo sprint / Moose dojo. It was a nice event with more than 15 motivated sprinters. With the help of candies, cakes and chocolate, huge work has been done' category: 'Pharo') visible: true);
      writeBlogPost: ((TBPost title: 'Brick on top of Bloc - Preview' text: 'We are happy to announce the first preview version of Brick, a new widget set created from scratch on top of Bloc. Brick is being developed primarily by Alex Syrel (together with Alain Plantec, Andrei Chis and myself), and the work is sponsored by ESUG. 
      Brick is part of the Glamorous Toolkit effort and will provide the basis for the new versions of the development tools.' category: 'Pharo') visible: true);
      writeBlogPost: ((TBPost title: 'The sad story of unclassified blog posts' text: 'So sad that I can read this.') visible: true);
       writeBlogPost: ((TBPost title: 'Working with Pharo on the Raspberry Pi' text: 'Hardware is getting cheaper and many new small devices like the famous Raspberry Pi provide new computation power that was one once only available on regular desktop computers.' category: 'Pharo') visible: true)
]]]


! Préparation de Sauvegarde Exterieure avec Voyage

Alors qu'avoir un modèle d'objets en mémoire fonctionne bien, et que des sauvegardes de l'image Pharo sauve aussi de tels objets, il est préférable 
de pouvoir sauver les objets dans une base de données exterieure. Voyage permet de sauver les objets dans une base de donnée Mongo. 
C'est ce que nous allons voir. Dans un premier temps nous allons utiliser la capacité de Voyage à simuler une base exterieure. Ceci est tres pratique en phase de développement. Dans un second nous installerons une base de données Mongo et nous y accéderons via la couche Voyage. 


!! Sauvegarde d'un blog

La première méthode à modifier est la méthode ==writeBlogPost:== pour sauver le blog.

[[[
TBBlog >> writeBlogPost: aPost
   "Write the blog post in database"
   posts add: aPost.
   self save 
]]]

Si vous essayez d'exécuter le test suivant, vous allez voir qu'il ne passe pas car le système rend 0 au lieu de 2 instances de posts.

[[[
TBBlogTest >> testAddBlogPost
   blog writeBlogPost: post.
   self assert: blog size equals: 2
]]]

Pourquoi cela arrive-t-il? En fait nous n'avons jamais dit quels objets devaient être sauvés dans la base de données.

La méthode de class ==isVoyageRoot== permet de déclarer que les objets de la classe ==TBBlog== doivent être sauvés dans la base. 

[[[
TBBlog class >> isVoyageRoot
   "Indicates that instances of this class are top level document in noSQL databases"
   ^ true
]]]

De plus nous devons soit créer une connexion sur une base de données réelle soit travailler en mémoire. C'est ce que nous faisons 
maintenant en utilisant cette expression. 

[[[
VOMemoryRepository new enableSingleton. 
]]]

Le message ==enableSingleton== indique à Voyage que nous n'utilisons qu'une seule base de donnée ce qui nous permet de ne pas avoir à préciser avec laquelle nous travaillons. 

Nous redéfinissons la méthode ==reset== pour nous assurer que l'endroit où la base est sauvée est réinitialisé lorsque que l'on charge le code. 

[[[
TBBlog class >> initialize
      self reset
      VOMemoryRepository new enableSingleton.
      
TBBlog class >> reset
   VORepository setRepository: nil.
   uniqueInstance := nil

]]]

L'expression ==VORepository setRepository: nil.== est une expression Voyage qui remet à zero la connexion avec la base de données Mongo qu'elle soit en mémoire ou extèrieure. Noter que ==enableSingleton== met à jour le repository comme le montre la méthode ci-dessous. 

[[[
VORepository >> enableSingleton
      self class setRepository: self
]]]

Nous pouvons aussi modifier la méthode ==removeAll== afin de sauver le nouvel état d'un blog. 

[[[
TBBlog >> removeAll
   posts := OrderedCollection new.
   self remove.
]]]


!! Utilisation de la Base

Alors même que la base est en mémoire et bien que nous pouvons accèder au blog en utilisant le singleton de la class ==TBBlog==,
nous allons montrer l'API offerte par Voyage. C'est la même API que nous pourrons utiliser pour accèder à une base mongo.

Nous créons des posts dans 
[[[
TBBlog createDemoPosts.
]]]

Nous pouvons compter le nombre de blog sauvés. Ici nous obtenons ce qui est normal puisque le blog est implémenté comme un singleton. 

[[[
TBBlog count
>1
]]]

De la même manière, nous pouvons sélectionner toutes objets sauvés. 
[[[
TBBlog selectAll
]]]


Vous pouvez voir l'API de Voyage en parcourant
- la classe ==Class==, et 
- la classe ==VORepository== qui est la racine d'héritage des bases de données en mémoire ou extérieur.

Ces queries sont plus pertinentes quand on a plus d'objets comme les posts d'un blog. 




!! Sauvegardons les postes [Optionel pour le moment]

On peut aussi définir qu'un poste est un élément qui peut être sauvegardé de manière autonome. Cela peut permettre de sauver des postes de manière indépendante d'un blog. Typiquement si nous representions les commentaires d'un post nous ne les declarerions pas comme racine car sauver ou manipuler un commentaire en dehors du context de son post ne fait pas beaucoup de sens.  Pour cela on nous définissons les méthodes suivantes:


[[[
TBPost class >> isVoyageRoot
   "Indicates that instances of this class are top level document in noSQL databases"
   ^ true
]]]

[[[
TBBlog >> writeBlogPost: aPost
   "Write the blog post in database"
   posts add: aPost.
   aPost save. 
   self save 
]]]


[[[
TBBlog >> removeAll
   posts do: [:each | each remove ].
   posts := OrderedCollection new.
   self remove.
]]]




!!! D'autres requêtes

Nous illustrons maintenant comment nous pouvons faire des requêtes sur la base en mémoire en incluant les posts. 

[[[
	TBBlog reset.
	TBBlog current allBlogPosts size.
	> 0

	TBBlog createDemoPosts.
	TBBlog current allBlogPosts size.
	> 5

	“Via repository"
	TBBlog count.
	> 1 
	TBPost count.
	> 5

	TBPost selectAll.
	TBPost selectAll do: [:each | Transcript show: each text; cr]

	TBBlog removeAll.
	TBBlog count.
	>0
	TBPost count.
	> 5 
	??? why the posts are still there

	TBPost removeAll.
	TBPost count.
	> 0
]]]

Nous allons maintenant utiliser une base mongo externe à Pharo. 


! Mongo
En utilisant Voyage nous pouvons rapidement sauver nos posts sur une base de données Mongo. Ce chapitre explique rapidement la mise en oeuvre et les quelques modifications que nous devons apporter a notre projet pour sauver en Pharo. 
Nous commencons 

!! Obtenir une base de données MongoDB

!!! Installation Locale

!!!! Mac OS X

- Installer Brew (*http://brew.sh*)

- Dans le terminal, mettre à jour les paquets et installer MongoDB:

[[[
brew update
brew install mongodb
]]]

- Créer un répertoire pour le stockage des données et attribution des droits

[[[
mkdir -p /data/db
chmod 770 /data/db
]]]

Lancement de mongo: ==[sudo] mongod==

Attention une fois que votre application utilise Mongo, il est important que Mongo soit lancé avant Pharo. 
Vous pouvez tester cela 

[[[

| server |
server := Mongo default.
[ server open ] 
   on: ConnectionTimedOut 
   do: [ :e | ^ false ].
^ server isOpen
]]]   

!!!! Linux Debian
Google pour le moment. A venir

!!!! Windows
Google pour le moment. A venir


!!! Dans le cloud avec MongoLab
Dans un premier temps vous pouvez passer cette étape si vous avez une installation locale.

- Se connecter sur *https://mongolab.com*
- Cliquer sur signup,
- Créer un compte utilisateur (un mail de vérification de l'adresse mail est envoyé. Il faut confirmer le compte).
- Cliquer sur "Create New"
- modèle d'hébergement: option "Single-node" et on sélectionne "Sandbox" (gratuit pour 0.5 Go)
- On fournit un nom ("tinyblog") pour la base de données (Database name)
- On clique sur "Create new MongoDB deployment",
- En cliquant sur le nom de la base Mongo, on accède à l'écran de configuration,
-- Les paramètres de configuration sont dans l'URL,
-- On clique sur l'onglet "Users", puis le bouton "Add database user" pour ajouter un nouvel utilisateur,

!!!! Configuration du compte

Pensez à changer les valeurs!

[[[
|Champs       |Valeur                  |
|-------------|------------------------|
|Account name |tinyblog                |
|Username     |tinyblog                |
|Email        |olivier.auverlot@free.fr|
|Password     |tinyblog2015            |
]]]

!!!! Paramètres du serveur

Lors de votre enregistrement sur mongolab vous obtenez des valeurs que nous pouvons utiliser. 

[[[
|Parametre      |Valeur                |
|---------------|----------------------|
|Serveur        |ds045064.mongolab.com |
|Port           |45064                 |
|Nom de la base |tinyblog              |
]]]

!!!! Utilisateur de la base tinyblog

[[[
|Champs       |Valeur      |
|-------------|------------|
|Compte       |tbuser      |
|Mot de passe |tbpassword  |
]]]





!! Revisitons le modèle

Nous revisitons maintenant le modèle. 

!!! Revisitons TBBlog

Nous améliorons la class ==TBBlog== pour introduire une référence a la base de donnee 

[[[
Object subclass: #TBBlog
   instanceVariableNames: 'repository posts'
   classVariableNames: ''
   package: 'TinyBlog'
]]]



!!!! Initialisation de la connexion


Coté instance, les méthodes ==initializeMongo== et ==initialize== établissent la connexion vers la base de données.
[[[
TBBlog >> initialize
	super initialize.
	posts := OrderedCollection new. 
	self initializeMongo
	
TBBlog >> initializeMongo

	repository := VOMongoRepository
		host: 'localhost'
		database: 'tinyblog'.
	repository enableSingleton.
]]]

[[[
TBBlog reset
]]]

@@note Pas d'authentification utilisée car impossible de le faire avec MongoDB 3.0 (nouvelle méthode de chiffrement SCRAM pas encore supportée avec Pharo)


Vous pouvez eviter de passer en mode mémoire donc la seconde ligne de la méthode ==initialize== suivante (invoquée lors du chargement du package) devient inutile. 

[[[
TBBlog class >> initialize
      self reset.
      VOMemoryRepository new enableSingleton.
]]]





















! Infrastructure Web

Nous commençons par définir une interface telle que celle que les utilisateurs la verrons. Dans un prochain chapitre nous développerons une interface d'administration que le possesseur du blog utilisera.
Nous allons définir des composants Seaside *http://www.seaside.st*. L'ouvrage de référence est disponible en ligne à *http://book.seaside.st*


!! Initialisation de l'application

Création d'une classe ==TBRootComponent== qui est le point d'entrée de l'application. Il sert à l'initialisation de l'application.

On déclare l'application au serveur Seaside, coté classe, dans le protocole 'initialize'. On en profite pour intégrer les dépendances du framework Bootstrap (les fichiers css et js seront stockés dans l'application).

[[[
TBRootComponent class >> initialize
   "self initialize"
   | app |
   app := WAAdmin register: self asApplicationAt: 'TinyBlog'.
   app
      addLibrary: JQDeploymentLibrary;
      addLibrary: JQUiDeploymentLibrary;
      addLibrary: TBSDeploymentLibrary
]]]

Dans un Playground, on peut exécuter ==TBRootComponent initialize== pour forcer l'exécution de la méthode ==initialize==. Notez que nous venons de la définir et donc il est nécessaire de l'exécuter pour en voir les bénéfices.

Les méthodes de classe ==initialize== sont invoquées automatiquement lors du chargement du package.

Une connexion sur le serveur Seaside ("Browse the applications installed in your image") permet de vérifier que l'application est bien enregistrée.

@todo  add Screenshot

Ajoutons également la méthode ==canBeRoot== afin de préciser que la classe ==TBRootComponent== est la première instanciée lors qu'un utilisateur se connecte sur l'application et représente une application et pas seulement un composant.

[[[
TBRootComponent >> canBeRoot
   ^ true
]]]

Ajoutons maintenant une méthode ==renderContentOn:== afin de vérifier que notre application répond bien. La méthode est une méthode d'instance dans le protocole rendering.

[[[
TBRootComponent >> renderContentOn: html
   html text: 'TinyBlog'
]]]

Connexion avec un navigateur sur *http://localhost:8080/TinyBlog*. La page doit apparaître.

@@todo ??? add Screenshot

Ajoutons maintenant des informations dans l'entête de la page HTML afin que TinyBlog ait un titre et soit une application HTML5. L'ensemble des composants visuels de l'application hériteront de ==TBRootComponent== et il ne sera donc pas nécessaire de reproduire cette opération.

[[[
TBRootComponent >> updateRoot: anHtmlRoot
   super updateRoot: anHtmlRoot.
   anHtmlRoot beHtml5.
   anHtmlRoot title: 'TinyBlog'.
]]]

@@todo je suis confus si ils sont tous root et tous update alors c'est pas le basard? esteban

Dans le cadre du développement, automatisons la création d'un ensemble de posts à l'aide de la méthode ==createDemoPosts== dans la classe ==TBBlog==.


[[[
TBBlog class >> createDemoPosts

   self uniqueInstance
      writeBlogPost: ((TBPost title: 'Welcome in TinyBlog' text: 'TinyBlog is a small blog engine made with Pharo.' category: 'TinyBlog') visible: true).
      writeBlogPost: ((TBPost title: 'Report Pharo Sprint' text: 'Friday, June 12 there was a Pharo sprint / Moose dojo. It was a nice event with more than 15 motivated sprinters. With the help of candies, cakes and chocolate, huge work has been done' category: 'Pharo') visible: true).
      writeBlogPost: ((TBPost title: 'Brick on top of Bloc - Preview' text: 'We are happy to announce the first preview version of Brick, a new widget set created from scratch on top of Bloc. Brick is being developed primarily by Alex Syrel (together with Alain Plantec, Andrei Chis and myself), and the work is sponsored by ESUG. Brick is part of the Glamorous Toolkit effort and will provide the basis for the new versions of the development tools.' category: 'Pharo') visible: true).
      writeBlogPost: ((TBPost title: 'The sad story of unclassified blog posts' text: 'So sad that I can read this.') visible: true).
      writeBlogPost: ((TBPost title: 'Working with Pharo on the Raspberry Pi' text: 'Hardware is getting cheaper and many new small devices like the famous Raspberry Pi provide new computation power that was one once only available on regular desktop computers. This capable little device called Pi enables people of all ages to explore computing and combined with powerful software environments like Pharo the Pi can be used for interesting projects.' category: 'Pharo') visible: true).
]]]

!! Gestion de Session

Un objet session est attribué à chaque instance de l'application. Il permet de conserver principalement des informations. 
Nous allons voir comment nous l'utilisons pour gérer une connexion.

[[[
WASession subclass: #TBSession
   instanceVariableNames: 'repository'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Nous allons l'utiliser pour fournir à chaque utilisateur la référence vers l'instance uniquement de ==TBBlog==.

[[[
TBSession >> repository
   ^ repository
]]]

[[[
TBSession >> repository: anObject
   repository := anObject
]]]

Le protocole 'initialize-release'' contient les méthodes ==initialize== et ==initializeRepository==. Celle-ci est appelée à chaque fois qu'un nouvel utilisateur se connecte à l'application (??? c'est quoi un nouvel utilisateur). Elle demande la création d'une instance de ==TBBlog== et celui-ci ne contient aucun posts, elle déclenche la création des posts de démonstration.

[[[
TBSession >> initializeRepository
   TBBlog initialize.
   self repository: TBBlog current.
   self repository size = 0 ifTrue: [ self repository createDemoPosts ]
]]]

[[[
TBSession >> initialize
   super initialize.
   self initializeRepository
]]]

Ajoutons maintenant une méthode ==initialize== dans le protocole 'initialize-release' de la classe ==TBRootComponent==.

[[[
TBRootComponent >> initialize
   super initialize.
   TBBlog initialize.
   self repository size = 0 ifTrue: [ self repository createDemoPosts ]
]]]

Il vous faut maintenant spécifier à Seaside qu'il doit utiliser l'objet ==TBSession== comme objet de session courant pour l'application TinyBlog. 
Pour cela, on utilise l'outil d'administration de Seaside.

- connexion sur *http://localhost:8080/config*,
- on clique sur "TinyBlog",
- Dans "General", cliquez sur le bouton "Override" de "Session Class",
- Choisir 'TBSession' dans la liste déroulante,
- Cliquez sur le bouton "Apply" en bas du formulaire.

@@todo ca serait bien d'automatiser cette étape à l'initialisation de l'application. esteban










! Composants Visuels de TinyBlog

Nous sommes prets à définir les composants visuels de notre petite application.
Les premiers chapitre de *http://book.seaside.st* peuvent vous aider.


!! Le composant TBScreenComponent

[[[
WAComponent subclass: #TBScreenComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Les différents composants d'interface de TinyBlog auront besoin d'accéder aux règles métier de l'application. Dans le protocole 'accessing', créons un méthode ==repository== qui retourne l'instance de ==TBBlog==. Celle-ci sera stockée dans la session de l'application et donc accessible dans tous les objets héritant de WAComponent (??? vraiment).

[[[
TBScreenComponent >> repository
   ^ self session repository
]]]

Profitons également de ce composant pour insérer dans la partie supérieure de chaque composant, l'instance d'un composant représentant l'entête de l'application.

!! Définition du composant TBHeaderComponent

[[[
WAComponent subclass: #TBHeaderComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Le protocole 'rendering' contient la méthode ==renderContentOn:== chargée d'afficher l'entête.

[[[
TBHeaderComponent >> renderContentOn: html
   html tbsNavbar beDefault with: [
      html tbsNavbarBrand
         url: '#';
         with: 'TinyBlog' ]
]]]

L'entête est affichée à l'aide d'une barre de navigation Bootstrap.

!!!! Améliorations possibles
Le nom du blog devrait être paramêtrable à l'aide d'une variable d'instance dans un objet ==TBConfiguration== ou à l'aide d'un document dans la base Mongo.


!! Ajout d'un Header

Il n'est pas souhaitable d'instancier systématiquement le composant à chaque fois qu'un composant est appelé. Créons une variable d'instance ==header== dans ==TBScreenComponent== qui sera initialisés une seule fois pour chaque utilisateur de l'application (gain de ressources).

[[[
WAComponent subclass: #TBScreenComponent
   instanceVariableNames: 'header'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Créons une méthode ==initialize== dans le protocole `initialize-release`:

[[[
TBScreenComponent >> initialize
   super initialize.
   header := TBHeaderComponent new.
]]]

!!! Relation Composite-Composant
Définissons que l'instance du composant ==TBHeaderComponent== est un enfant de ==TBScreenComponent== dans la hiérarchie de composants Seaside (en non entre classes Pharo). En effet en Seaside les sous-composants d'un composant doivent être retournés par le composite par le message ==children==.

[[[
TBScreenComponent >> children
   ^ OrderedCollection with: header
]]]

Affichons maintenant le composant dans la méthode ==renderContentOn:== (protocole 'rendering'):

[[[
TBScreenComponent >> renderContentOn: html
   self render: header
]]]

!!! Liste des Posts

Nous allons afficher la liste des posts (acces public). Dans le future, nous  proposerons une interface administrative des posts.

A l'aide du jeu de test, nous construisons le composant public de l'application qui affiche les blogs.

Créons un composant ==TBPublicPostsListComponent== qui hérite de ==TBScreenComponent==:

[[[
TBScreenComponent subclass: #TBPublicPostsListComponent
   instanceVariableNames: 'report'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Ajoutons une méthode ==renderContentOn:== (protocole rendering) provisoire pour tester l'avancement de notre application.

[[[
TBPublicPostsListComponent >> renderContentOn: html
   super renderContentOn: html
   html text: 'Blog Posts here !!!'
]]]

Maintenant, revenons au composant ==TBRootComponent== et ajoutons une variable d'instance ==publicPostsList== qui contiendra (pour chaque utilisateur) l'instance du composant ==TBPublicPostsListComponent== (économie de ressources).
??? TBRootComponent = TBBlogComponent

[[[
WAComponent subclass: #TBRootComponent
   instanceVariableNames: 'publicPostsList'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

[[[
TBRootComponent >> publicPostsList
   ^ publicPostsList
]]]
[[[
TBRootComponent >> publicPostsList: anObject
   publicPostsList := anObject
]]]
[[[
TBRootComponent >> registerSubComponents
   self publicPostsList: TBPublicPostsListComponent new
]]]
[[[
TBRootComponent >> initialize
   super initialize.
   self registerSubComponents
]]]

Children missing ???
[[[
TBRootComponent >> children
   ^ OrderedCollection with: publicPostsList
]]]




La méthode ==renderContentOn:== affiche, au démarrage de l'application, la liste des posts dans la base.

[[[
TBRootComponent >> renderContentOn: html
   html render: self publicPostsList
]]]

!! Le composant Post

Nous allons maintenant définir le composant ==TBPostContentComponent== qui affiche le contenu d'un post.

Chaque post du blog sera représenté visuellement par une instance de  ==TBPostContentComponent== qui affiche le titre, la date et le contenu d'un post.

[[[
WAComponent subclass: #TBPostContentComponent
   instanceVariableNames: 'title text date'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBPostContentComponent >> title
   ^ title

TBPostContentComponent >> title: anObject
   title := anObject

TBPostContentComponent >> text
   ^ text

TBPostContentComponent >> text: anObject
   text := anObject

TBPostContentComponent >> date
   ^ date

TBPostContentComponent >> date: anObject
   date := anObject
]]]

Créons une méthode de classe pour initialiser chaque post:

[[[
TBPostContentComponent class >> title: aTitle text: aText date: aDate
   ^ self new
      title: aTitle;
      text: aText;
      date: aDate
]]]

Ajoutons la méthode ==renderContentOn:== qui définie l'affichage du post.

[[[
TBPostContentComponent >> renderContentOn: html
   html heading level: 2; with: self title.
   html heading level: 6; with: self date.
   html text: self text
]]]

Nous montrerons dans le chapitre décrivant Magritte puis les interfaces d'administration, qu'il est rare
de définir un composant de manière aussi manuelle. En effet Magritte en décrivant les données manipuler
permet de générer automatiquement des composantes Seaside. Le code équivalent serait comme suit: 

[[[
TBPostContentComponent >> renderContentOn: html
   html render: self asComponent
]]]


!! Afficher les posts

Maintenant nous pouvons afficher des posts présents dans la base.

Il ne reste plus qu'à modifier la méthode ==TBPublicPostsListComponent >> renderContentOn:== pour afficher l'ensemble des blogs visibles présents dans la base.

[[[
TBPublicPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   self repository allVisibleBlogPosts do: [ :p |
      html render: (TBPostContentComponent
         title: p title
         text: p text
         date: p date).
   ]
]]]

!!! Affichage des posts par catégorie


!!! Categories

Nous allons créer un composant pour gérer une liste de catégories nommée: ==TBCategoriesListComponent==.

Les posts sont classés par catégorie. Par défaut, si aucune catégorie n'a été précisée, ils sont rangés dans une catégorie spéciale dénommée "Unclassified".

Nous avons besoin d'un composant Seaside qui affiche la liste des catégories présentes dans la base et permet d'en sélectionner une. Ce composant devra donc avoir la possibilité de communiquer avec le composant ==TBPublicPostsListComponent== afin de lui communiquer la catégorie choisie par l'utilisateur.

[[[
WAComponent subclass: #TBCategoriesListComponent
   instanceVariableNames: 'categories postsListScreen'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBCategoriesListComponent >> categories
   ^ categories

TBCategoriesListComponent >> categories: anObject
   categories := anObject

TBCategoriesListComponent >> postsListScreen
   ^ postsListScreen

TBCategoriesListComponent >> postsListScreen: anObject
   postsListScreen := anObject
]]]

[[[
TBCategoriesListComponent class >> categories: aCollectionOfCategories postsListScreen: aTBScreen
   ^self new categories: aCollectionOfCategories; postsListScreen: aTBScreen
]]]

La méthode ==selectCategory== (protocole 'action') communique au composant ==TBPublicPostsListComponent== la nouvelle catégorie courante.

[[[
TBCategoriesListComponent >> selectCategory: aCategory
   self postsListScreen currentCategory: aCategory
]]]

Nous avons donc besoin d'ajouter une variable d'instance dans ==TBPublicPostsListComponent==.

[[[
TBScreenComponent subclass: #TBPublicPostsListComponent
   instanceVariableNames: 'currentCategory'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBScreenComponent >> currentCategory
   ^ currentCategory

TBScreenComponent >> currentCategory: anObject
   currentCategory := anObject
]]]

Nous pouvons ajouter une méthode (protocole 'rendering') pour afficher les catégories sur la page.

[[[
??? >> renderCategoryLinkOn: html with: aCategory
   html tbsLinkifyListGroupItem
      callback: [ self selectCategory: aCategory ];
      with: aCategory
 
]]]

Reste maintenant à écrire la méthode de rendu du composant:

[[[
??? >> renderContentOn: html
   html tbsListGroup: [
      html tbsLinkifyListGroupItem beActive; with: 'Categories'.
      categories do: [ :c | self renderCategoryLinkOn: html with: c ].
   ]
]]]

!! Mise à jour des Posts
Nous devons aussi mettre à jour la liste des posts.

Il faut gérer le raffraîchissement de la liste des posts en fonction de la catégorie choisie et donc modifier la méthode de rendu du composant ==TBPublicPostsListComponent==.

La méthode ==readSelectedPosts== récupère dans la base les posts à afficher. Si elle vaut ==nil==, l'utilisateur n'a pas encore sélectionner une catégorie et l'ensemble des posts visibles de la base est affiché. Si elle contient une valeur autre que ==nil==, l'utilisateur a sélectionné une catégorie et l'application affiche alors la liste des posts attachés à la catégorie.

[[[
TBPublicPostsListComponent >> readSelectedPosts
   ^ self currentCategory
      ifNil: [ self repository allVisibleBlogPosts ]
      ifNotNil: [ self repository allVisibleBlogPostsFromCategory: self currentCategory  ].
]]]

@@todo Olivier maintenant on ne doit plus avoir besoin de faire un test car la caetgory est definie tout le temps

Nous pouvons maintenant modifier la méthode chargée du rendu de la liste des posts:

[[[
TBPublicPostsListComponent >> renderContentOn: html
   super renderContentOn: html.

   html render: (TBCategoriesListComponent
               categories: (self repository allCategories)
               postsListScreen: self).

   self readSelectedPosts do: [ :p |
      html render: (TBPostContentComponent
         title: p title
         text: p text
         date: p date).
   ]
]]]

Une instance du composant ==TBCategoriesListComponent== est ajoutée sur la page et permet de sélectionner la catégorie courante.


!! Look et Agencement

Nous allons maintenant agencer le composant ==TBPublicPostsListComponent==.

Mise en place d'un responsive design pour la liste des posts. Les composants sont placés dans un container Bootstrap puis agencés sur une ligne avec deux colonnes. La dimension des colonnes est déterminée en fonction de la résolution (viewport) du terminal utilisé. Les 12 colonnes de Bootstrap sont réparties entre la liste des catégories et la liste des posts. Dans le cas d'une résolution faible, la liste des catégories est placée au dessus de la liste des posts (chaque élément occupant 100\% de la largeur du container).

Tant que nous sommes dans les finitions, profitons en également pour afficher la date de chaque post dans un format compréhensible (sans l'heure).
[[[
TBPublicPostsListComponent >> renderContentOn: html

   super renderContentOn: html.
    html tbsContainer: [
      html tbsRow showGrid;
         with: [
            html tbsColumn
               extraSmallSize: 12;
               smallSize: 2;
               mediumSize:  4;
               with: [
                  html render: (TBCategoriesListComponent
                     categories: (self repository allCategories)
                     postsListScreen: self) ].
            html tbsColumn
               extraSmallSize: 12;
               smallSize: 10;
               mediumSize: 8;
               with: [ self readSelectedPosts do: [ :p |
                  html render: (TBPostContentComponent
                     title: p title
                     text: p text
                     date: p date asDate) ] ] ] ]
]]]



! Décrire les données avec Magritte

@@todo Pourquoi utiliser Magritte ? Il évite d'écrire à la main les formulaires, de valider les données, permet de générer des rapports. add reference au booklet

Dans ce chapitre, les cinq variables d'instance de l'objet ==TBPost== sont décrites à l'aide de Magritte. Ici, nous ne nous intéressons qu'aux données (les informations sur l'apparence des données dans l'application seront renseignées plus tard).

!! Descriptions 
Les cinq méthodes sont dans le protocole 'descriptions' de la classe ==TBPost==.

Le titre d'un post est une chaine de caractères devant être obligatoirement complétée.

[[[
TBPost >> descriptionTitle
   <magritteDescription>
   ^ MAStringDescription new
      accessor: #title;
      beRequired;
      yourself
]]]

Le texte d'un post est une chaine de caractères multi-lignes devant être obligatoirement complétée.

[[[
TBPost >> descriptionText
   <magritteDescription>
   ^ MAMemoDescription new
      accessor: #text;
      beRequired;
      yourself
]]]

La catégorie d'un post est une chaine de caractères qui peut ne pas être renseignée. Dans ce cas, le post sera de toute manière rangé dans la catégorie "Unclassified".

[[[
TBPost >> descriptionCategory
   <magritteDescription>
   ^ MAStringDescription new
      accessor: #category;
      yourself
]]]

La date de création d'un post est importante car elle permet de définir l'ordre de tri pour l'affichage des posts. C'est donc une variable d'instance contenant obligatoirement une date.

[[[
TBPost >> descriptionDate
   <magritteDescription>
   ^ MADateDescription new
      accessor: #date;
      beRequired;
      yourself
]]]



La variable d'instance ==visible== doit obligatoirement contenir une valeur booléenne.

[[[
descriptionVisible
   <magritteDescription>
   ^ MABooleanDescription new
      accessor: #visible;
      beRequired;
      yourself
]]]
   
!!! Ameliorations possibles

Voici quelques améliorations

Nous pourrions améliorer cette description pour qu'il ne soit pas possible de poster un post ayant une date antèrieure celle d'ajourd'hui.

Nous pourrions changer la description d'une categorie pour en definir un enumere parmi les categories existantes. Ceci permettrait de faire une interface plus simplement.






! Administration de TinyBlog




! Design Relationel

Voici une conception qui s'adapte plus a un modele de base de données relationnelle.

!!! La classe TBBlog
La classe ==TBBlog== collecte les posts. Cependant comme Voyage nous offre une base de donnees en mémoire que nous pouvons par la suite déportée sur une base Mongo exterieur, la classe ==TBBlog== ne pointe pas directement sur les objets posts mais le fait via l'intermédiaire de la base de données. Nous allons développer ==TBBlog== en écrivant des tests puis les implémentant. 

[[[
Object subclass: #TBBlog
   instanceVariableNames: 'repository'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Ici nous definissons le fait que la base de donnée fonctionne en mémoire par l'utilisation de ==VOMemoryRepository new==.
[[[
TBBlog >> iinitializeInMemory
   super initialize.
   repository := VOMemoryRepository new.
   repository enableSingleton.

TBBlog >> initialize
   super initialize.
   self initializeInMemory.
]]]



!!!! Une seule base

Il y a une seule instance de la classe (singleton) et celle-ci est construite coté classe comme suit.

[[[
TBBlog class
   instanceVariableNames: 'uniqueInstance'

TBBlog class >> reset
   VORepository setRepository: nil.
   uniqueInstance := nil

TBBlog class >> current
   "answer the instance of the TBRepository"
   ^ uniqueInstance ifNil: [ uniqueInstance := self new ]

TBBlog class >> initialize
   self reset
]]]

L'expression ==VORepository setRepository: nil.== est une expression Voyage qui détruit la connexion avec la base de données Mongo qu'elle soit en mémoire ou extèrieure.


!! Tester les règles métiers
Nous allons écrire les tests pour les règles métiers et ceci en mode TDD (Test Driven Development) c'est-à-dire en développant les tests en premiers puis en définissant les fonctionalités jsuqu'à ce que les tests passent.

Les tests unitaires sont regroupés dans le paquet ==TinyBlog-tests== qui contient la classe ==TBBlogTest==.

[[[
TestCase subclass: #TBBlogTest
   instanceVariableNames: 'blog post first'
   classVariableNames: ''
   category: 'TinyBlog-Tests'
]]]

Avant le lancement des tests, la méthode ==setUp== initialise la connexion vers la base, efface son contenu, ajoute un post et en crée un autre qui provisoirement n'est pas enregistré.

[[[
TBBlogTest >> setUp
   blog := TBBlog current.
   blog removeAll.
   
   first := (TBPost title: 'A title' text: 'A text' category: 'First Category').
   blog writeBlogPost: first.
   
   post := (TBPost title: 'Another title' text: 'Another text' category: 'Second Category') beVisible
]]]

On en profite pour tester différentes configuration. Les posts ne sont pas dans la même catégorie, l'un est visible, l'autre pas.

La méthode ==tearDown== exécutée au terme des tests remet à zéro la connexion.

[[[
TBBlogTest >> tearDown
   TBBlog reset
]]]

Nous allons développer les tests d'abord puis ensuite passer à l'implémentation
des fonctionalités.


!!!!

[[[
TBBlogTest >> testAddBlogPost
   blog writeBlogPost: post.
   self assert: blog size equals: 2
]]]

Ce test ne marche pas car nous n'avons pas défini ==writeBlogPost:== et ==removeAll==.

[[[
TBBlog >> removeAll
   repository removeAll: TBPost
]]]

[[[
TBBlog >> writeBlogPost: aPost
   "Write the blog post in database"
   aPost save
]]]

[[[
TBBlog >> size
   ^ repository count: TBPost
]]]

If you run the test, it will fail because the system returns 0 instances of posts instead of 2. 
Why this is happening? We never told the system that posts are objects that should be saved in the database.

[[[
TBPost class >> isVoyageRoot
   "Indicates that instances of this class are top level document in noSQL databases"
   ^ true
]]]

Ecrivons un test pour couvrir les fonctionalités que nous venons de développer. 

!!!! Obtenir le nombre de posts dans la base


[[[
TBBlogTest >> testSize
   self assert: blog size equals: 1
]]]

!!!! Effacer l'intégralité des posts

[[[
TBBlogTest >> testRemoveAllBlogPosts
   blog removeAll.
   self assert: blog size equals: 0.
]]]


!!! Quelques autres fonctionalités

Nous définissons les fonctionalités et nous assurons que les tests passent. 
Les règles métiers sont regroupées dans le protocole 'action' de la classe ==TBBlog==.

!!!! Obtenir l'ensemble des posts (visibles et invisibles)


[[[
TBBlogTest >> testAllBlogPosts
   blog writeBlogPost: post.
   self assert: (blog allBlogPosts) size equals: 2.
]]]

[[[
TBBlog >> allBlogPosts
   ^ repository selectAll: TBPost
]]]


!!!! Obtenir tous les posts visibles

[[[
TBBlogTest >> testAllVisibleBlogPosts
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPosts) size equals: 1.
]]]

[[[
TBBlog >> allVisibleBlogPosts
   ^ (repository selectAll: TBPost) select: [ :p | p isVisible ]
]]]


!!!! Obtenir tous les posts d'une catégorie

[[[
TBBlogTest >> testAllBlogPostsFromCategory
   self assert: (blog allBlogPostsFromCategory: 'First Category') size equals: 1
]]]

[[[
TBBlog >> allVisibleBlogPostsFromCategory: aCategory
   ^(repository selectMany: TBPost where: [ :p | p category = aCategory ]) select: [ :p | p isVisible ]
]]]


!!!! Obtenir tous les posts visibles d'une catégorie

[[[
TBBlogTest >> testAllVisibleBlogPostsFromCategory
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPostsFromCategory: 'First Category') size equals: 0.
   self assert: (blog allVisibleBlogPostsFromCategory: 'Second Category') size equals: 1.
]]]

[[[
TBBlog >> allBlogPostsFromCategory: aCategory
   ^repository selectMany: TBPost where: [ :p | p category = aCategory ]
]]]

!!!! Vérifier la gestion des posts non classés

[[[
TBBlogTest >> testUnclassifiedBlogPosts
   self assert: (blog allBlogPosts select: [ :p | p isUnclassified ]) size equals: 0.
]]]

!!!! Obtenir la liste des catégories

[[[
TBBlogTest >> testAllCategories
   blog writeBlogPost: post.
   self assert: (blog allCategories) size equals: 2.
]]]

[[[
TBBlog >> allCategories
   ^(self allBlogPosts collect: [ :p | p category ]) asSet
]]]

!! Futures Evolutions

Plusieurs évolutions peuvent être apportées telles que obtenir uniquement la liste des catégories contenant au moins un post visible, effacer une catégorie et les posts contenus, renommer un catégorie, déplacer un post d'une catégorie à une autre, rendre visible ou invisible une catégorie et son contenu, etc. Nous vous encourageons à les développer.



 
